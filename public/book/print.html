<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>DMG-01: How to Emulate a Game Boy</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="architecture_overview.html"><strong aria-hidden="true">2.</strong> Architecture Overview</a></li><li><a href="cpu/introduction.html"><strong aria-hidden="true">3.</strong> CPU</a></li><li><ol class="section"><li><a href="cpu/registers.html"><strong aria-hidden="true">3.1.</strong> CPU Registers</a></li><li><a href="cpu/register_data_instructions.html"><strong aria-hidden="true">3.2.</strong> Instructions on Register Data</a></li><li><a href="cpu/executing_instructions.html"><strong aria-hidden="true">3.3.</strong> Instruction Execution and Control Flow</a></li><li><a href="cpu/reading_and_writing_memory.html"><strong aria-hidden="true">3.4.</strong> Instructions for Reading and Writting to Memory</a></li><li><a href="cpu/conclusion.html"><strong aria-hidden="true">3.5.</strong> Finishing Up the CPU</a></li></ol></li><li><a href="graphics/introduction.html"><strong aria-hidden="true">4.</strong> Graphics</a></li><li><ol class="section"><li><a href="graphics/tile_ram.html"><strong aria-hidden="true">4.1.</strong> Tile RAM</a></li></ol></li><li><a href="memory_map.html"><strong aria-hidden="true">5.</strong> Memory Map</a></li><li><a href="appendix/index.html"><strong aria-hidden="true">6.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix/numbers.html"><strong aria-hidden="true">6.1.</strong> Numbers</a></li><li><a href="appendix/number_notations.html"><strong aria-hidden="true">6.2.</strong> Number Notations</a></li><li><a href="appendix/bit_manipulation.html"><strong aria-hidden="true">6.3.</strong> Bit Manipulation</a></li><li><a href="appendix/resources.html"><strong aria-hidden="true">6.4.</strong> Resources</a></li><li><a href="appendix/instruction_guide/index.html"><strong aria-hidden="true">6.5.</strong> Instruction Guide</a></li><li><a href="appendix/cartridge_header.html"><strong aria-hidden="true">6.6.</strong> Cartridge Header</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">DMG-01: How to Emulate a Game Boy</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#introduction" id="introduction"><h1>Introduction</h1></a>
<p>If you really want to know how a particular computer works, there's no better way to learn than by emulating that computer. In this book, we'll be looking at one of the most loved computers of all time, Nintendo's Game Boy. We'll be going through the process from nothing and building the Game Boy up piece by piece. In the process not only will we learn more about the Game Boy itself, but we'll also get a good glimpse into how computers work in general as well as how to build emulators for other computer systems.</p>
<a class="header" href="#what-you-need-to-know" id="what-you-need-to-know"><h2>What You Need to Know</h2></a>
<p>We'll be assuming only basic programming knowledge and basic knowledge of the terminal. If you've programmed in almost any other language before you should be good to go. The particular language we'll be using is the <a href="https://www.rust-lang.org">Rust programming language</a>, but if you've never used Rust, don't worry; we'll be taking things slow, and I'll do my best to link to relevant learning material as things come up. If you want to get a head start on learning the basics of Rust, the amazing <a href="https://doc.rust-lang.org/book/second-edition/index.html">Rust book</a> is a great way to learn.</p>
<p>If you've already build emulators before, and are just looking for a reference specific to the Game Boy, you might find this book to be too detailed. I recommend the <a href="http://bgb.bircd.org/pandocs.htm">Pan Docs</a> as a great place to quickly learn the nity-grity of the Game Boy. You'll find even more resources in the <a href="./appendix/resources.html">resources guide</a>.</p>
<a class="header" href="#why-rust" id="why-rust"><h2>Why Rust?</h2></a>
<p>For many emulation projects performance is a key consideration. This means that emulators are often written in low-level languages that allow the programmer to easily write performant code. While our Game Boy emulator could be written in other languages like JavaScript or Python, it's best to use a language that would be appropriate for more resource intensive emulation (e.g. Sony's PlayStation 2 or Nintendo's Wii) so these skills can be used for future emulation projects. Rust fits the bill perfectly here.</p>
<p>While there are other languages that allow the performance needed for emulation like C and C++, Rust has the added bonus of being much more beginner friendly than C or C++. Unlike these older languages Rust has a solid package manager, testing framework and build tool that will feel familiar to users of more modern languages. Rust's community is also fantastic and generally very helpful.</p>
<p>Finally, Rust also has a great cross platform story - we'll be focusing on web and on desktop, but in the future, we might also be able to bring our emualtor to mobile platforms and embedded devices!</p>
<a class="header" href="#setup" id="setup"><h2>Setup</h2></a>
<p>In order to get started, you'll only need your favorite text editor and Rust related tooling. Follow the instructions <a href="https://www.rust-lang.org/en-US/install.html">on the Rust website</a> for how to install the rustup tool which gives you access to the Rust compiler, the Rust build tool and package manager called Cargo, as well as some other tools that we'll be using later on in our journey.</p>
<p>If you've successfully been able to install Rust you can create a new project by running the following command in your terminal:</p>
<pre><code class="language-bash">cargo new emulator
</code></pre>
<p>Navigate into your project's directory and have a look around. To run your project run the following:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<p>You're all good to go! Let's get emulating!</p>
<a class="header" href="#architecture-overview" id="architecture-overview"><h1>Architecture Overview</h1></a>
<p>Before we can begin we need to have a basic understanding of what is needed to build a Game Boy emulator. This starts by having a basic understanding of the Game Boy computer architecture. If you're already familiar with the very basics of CPUs, computer memory and I/O devices, you can skip to the next page.</p>
<a class="header" href="#at-a-high-level" id="at-a-high-level"><h2>At a High Level</h2></a>
<p>The Gameboy can be thought to contain the following pieces:</p>
<a class="header" href="#cpu-central-processing-unit" id="cpu-central-processing-unit"><h4>CPU (Central Processing Unit)</h4></a>
<p>The CPU is the &quot;brains&quot; of a computer. The CPU is responsible for the following:</p>
<ul>
<li>Executing instructions defined by the game the Game Boy is running</li>
<li>Reading and writting to memory</li>
<li>Reacting to &quot;events&quot; (known as interrupts) that come from the I/O (input/output) hardware such as the screen and the gamepad controls</li>
<li>Keeping track of very small pieces of data in &quot;registers&quot; that it manipulates when it runs instructions</li>
</ul>
<a class="header" href="#ram-random-access-memory" id="ram-random-access-memory"><h4>RAM (Random Access Memory)</h4></a>
<p>This is the piece of hardware that allows the Game Boy to remember data while it is running. Without the RAM, the Gameboy's CPU could still execute instructions and keep track of small pieces of data in its registers, but if the data no longer fits in its registers, the CPU would have to throw it away.</p>
<a class="header" href="#rom-read-only-memory" id="rom-read-only-memory"><h3>ROM (Read Only Memory)</h3></a>
<p>This is memory that has been &quot;hardcoded&quot; into the machine (hence it being read only). This memory is used to tell the machine how to set itself up (a.k.a bootstrap) to be able to begin accepting instructions as well as to play the <a href="https://www.youtube.com/watch?v=jCfPojZ_xLw">iconic splash screen</a> on boot.</p>
<p>Game cartridges are also known as ROMs as they are mostly read only memory as well.</p>
<a class="header" href="#io-inputoutput" id="io-inputoutput"><h3>I/O (Input/Output)</h3></a>
<p>The Gameboy has several pieces of I/O hardware:</p>
<ul>
<li>The screen,</li>
<li>Hardware dedicated to playing sounds,</li>
<li>A gamepad that the player uses to interact with the game through pushing various buttons.</li>
</ul>
<p>We'll discuss how the CPU can interface with this hardware much later in the book.</p>
<blockquote>
<p><strong>Learn More</strong></p>
<p>If you're interested in learning more about how computers work all the way down to the electrical level, I suggest watching Ben Eater's series on <a href="https://www.youtube.com/user/eaterbc">making an 8-bit Breadboard Computer</a>. Ben does an absolutely wonderful job of explaining how CPUs, RAM, ROM and even I/O devices are built from the ground up!</p>
</blockquote>
<p>Now that we have a small overview of the pieces we'll be talking about, let's take a closer look at the CPU!</p>
<a class="header" href="#cpu" id="cpu"><h1>CPU</h1></a>
<p>The Game Boy's CPU is a custom chip called the Sharp LR35902. The chip is very similar to the much more popular <a href="https://en.wikipedia.org/wiki/Intel_8080">Intel 8080</a> and the <a href="https://en.wikipedia.org/wiki/Zilog_Z80">Zilog Z80</a>. The 8080 was used by lots of different computers in the 70s and 80s including the very first comercially successful personal computer the <a href="https://en.wikipedia.org/wiki/Altair_8800">Altair 8800</a>. The Z80 was also a very popular chip being used in many home electronic devices including in many Sega home consoles such as the Master System and the Sega Genesis/Mega Drive.</p>
<p>We won't go into the specifics of what makes the LR35902 different from the Intel 8080 or Z80, but in general it's good to know that a large portion of what we'll learn about this custom chip will be applicable to other popular chips from yesteryear.</p>
<p>In the next few sections we'll be looking at the different CPU instructions that the LR35902 can execute as long with how it reads instructions from memory, decodes them and updates its internal state as well as the contents of memory and different I/O devices.</p>
<a class="header" href="#cpu-registers" id="cpu-registers"><h1>CPU Registers</h1></a>
<p>In the previous chapter we outlined some of things that the CPU is responsible for. In this chapter we'll be focusing on just one of them: saving small amounts of data into registers.</p>
<a class="header" href="#overview" id="overview"><h2>Overview</h2></a>
<p>The Game Boy's CPU is a custom chip made just for the Game Boy. The chip is extremely similar to the <a href="https://en.wikipedia.org/wiki/Intel_8080">Intel 8080</a> which is itself similar to the <a href="https://en.wikipedia.org/wiki/Zilog_Z80">Zilog Z80</a>. While the Intel 8080 and Zilog Z80 were used in many different computers in the 70s and 80s, the chip inside the Game Boy was just used for the Game Boy. Most of what's true about how the 8080 and Z80 work is also true of the Game Boy's chip. We won't go into details on how exactly they differ, but it's important to be aware that while they're similar to the Game Boy's chip, they're not exactly the same.</p>
<a class="header" href="#registers" id="registers"><h2>Registers</h2></a>
<p>The CPU is composed of 8 different &quot;registers&quot;. Registers are responsible for holding on to little pieces of data that the CPU can manipulate when it executes various instructions. The Game Boy's CPU is an 8-Bit CPU, meaning that each of its registers can hold 8 bits (a.k.a 1 byte) of data. The CPU has 8 different registers labled as &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;h&quot;, &quot;l&quot;.</p>
<p>Let's get started building our CPU by specing out the registers in code:</p>
<pre><code class="language-rust noplaypen">struct Registers {
  a: u8,
  b: u8,
  c: u8,
  d: u8,
  e: u8,
  f: u8,
  h: u8,
  l: u8,
}
</code></pre>
<p>We use the type <code>u8</code> for our registers. <code>u8</code> are 8-bit unsigned integers. For a refresher on how numbers are stored in computers, checkout the <a href="./appendix/numbers.html">guide on numbers</a>.</p>
<p>While the CPU only has 8 bit registers, there are instructions that allow the game to read and write 16 bits (i.e. 2 bytes) at the same time (denoted as <code>u16</code> in Rust - a 16 bit unsigned integer). Therefore, we'll need the ability to read an write these &quot;virtual&quot; 16 bit registers. These registers are refered to as &quot;af&quot; (&quot;a&quot; and &quot;f&quot; combined), &quot;bc&quot; (&quot;b&quot; and &quot;c&quot; combined), &quot;de&quot; (&quot;d&quot; and &quot;e&quot; combinded), and finally &quot;hl&quot; (&quot;h&quot; and &quot;l&quot; combined). Let's implement &quot;bc&quot;:</p>
<pre><code class="language-rust noplaypen"># struct Registers { a: u8, b: u8, c: u8, d: u8, e: u8, f: u8, h: u8, l: u8, }
impl Registers {
  fn get_bc(&amp;self) -&gt; u16 {
    (self.b as u16) &lt;&lt; 8
    | self.c as u16
  }

  fn set_bc(&amp;mut self, value: u16) {
    self.b = ((value &amp; 0xFF00) &gt;&gt; 8) as u8;
    self.c = (value &amp; 0xFF) as u8;
  }
}
</code></pre>
<p>Here we see our first instance of &quot;bit manipulation&quot; through the use of four bitwise operators: &quot;&gt;&gt;&quot;, &quot;&lt;&lt;&quot;, &quot;&amp;&quot;, and &quot;|&quot;. If you're unfamiliar with or feel a bit rusty using these types of operators, check out the <a href="./appendix/bit_manipulation.html">guide on bit manipulation</a>.</p>
<p>For reading the &quot;bc&quot; register we first treat the &quot;b&quot; register as a <code>u16</code> (this effectively just adds a byte of all 0s to the most significant position of the number). We then shift the &quot;b&quot; register 8 positions so that it's occupying the most significant byte position. Finally, we bitwise OR the &quot;c&quot; register. The result is a two byte number with the contents of &quot;b&quot; in the most significant byte position and the contents of &quot;c&quot; in the least significant byte position.</p>
<a class="header" href="#flags-register" id="flags-register"><h2>Flags Register</h2></a>
<p>We're almost done with our registers, but there's one thing we way we can improve our registers for use later. The &quot;f&quot; register is a special register called the &quot;flags&quot; register. The lower four bits of the register are <em>always</em> 0s and the CPU automatically writes to the upper four bits when certain things happen. In other words, the CPU &quot;flags&quot; certain states. We won't go into the specific meanings of the flags just yet, but for now just know that they have the following names and positions:</p>
<ul>
<li>Bit 7: &quot;zero&quot;</li>
<li>Bit 6: &quot;subtraction&quot;</li>
<li>Bit 5: &quot;half carry&quot;</li>
<li>Bit 4: &quot;carry&quot;</li>
</ul>
<p>Here's a diagram of the flags register:</p>
<pre><code class="language-ignore">   ┌-&gt; Carry
 ┌-+&gt; Subtraction
 | |
1111 0000
| |
└-+&gt; Zero
  └-&gt; Half Carry
</code></pre>
<p>So while we could continue modeling our flags register as a simple 8-bit number (after all, that's all it is in reality), it might be less error prone to explicitly model the fact that the upper 4 bits (a.k.a the upper &quot;nibble&quot;) has specific meaning and the lower 4 bits (a.k.a the lower &quot;nibble&quot;) must always be zeros.</p>
<p>For this reason we'll make a struct called the <code>FlagsRegister</code>:</p>
<pre><code class="language-rust noplaypen">struct FlagsRegister {
    zero: bool,
    subtract: bool,
    half_carry: bool,
    carry: bool
}
</code></pre>
<p>Since we might need to look at this register as an 8-bit number, we can implement some traits from the standard library that make this easy:</p>
<pre><code class="language-rust noplaypen"># struct FlagsRegister {
#    zero: bool,
#    subtract: bool,
#    half_carry: bool,
#    carry: bool
# }
const ZERO_FLAG_BYTE_POSITION: u8 = 7;
const SUBTRACT_FLAG_BYTE_POSITION: u8 = 6;
const HALF_CARRY_FLAG_BYTE_POSITION: u8 = 5;
const CARRY_FLAG_BYTE_POSITION: u8 = 4;

impl std::convert::From&lt;FlagsRegister&gt; for u8  {
    fn from(flag: FlagsRegister) -&gt; u8 {
        (if flag.zero       { 1 } else { 0 }) &lt;&lt; ZERO_FLAG_BYTE_POSITION |
        (if flag.subtract   { 1 } else { 0 }) &lt;&lt; SUBTRACT_FLAG_BYTE_POSITION |
        (if flag.half_carry { 1 } else { 0 }) &lt;&lt; HALF_CARRY_FLAG_BYTE_POSITION |
        (if flag.carry      { 1 } else { 0 }) &lt;&lt; CARRY_FLAG_BYTE_POSITION
    }
}

impl std::convert::From&lt;u8&gt; for FlagsRegister {
    fn from(byte: u8) -&gt; Self {
        let zero = ((byte &gt;&gt; ZERO_FLAG_BYTE_POSITION) &amp; 0b1) != 0;
        let subtract = ((byte &gt;&gt; SUBTRACT_FLAG_BYTE_POSITION) &amp; 0b1) != 0;
        let half_carry = ((byte &gt;&gt; HALF_CARRY_FLAG_BYTE_POSITION) &amp; 0b1) != 0;
        let carry = ((byte &gt;&gt; CARRY_FLAG_BYTE_POSITION) &amp; 0b1) != 0;

        FlagsRegister {
            zero,
            subtract,
            half_carry,
            carry
        }
    }
}
</code></pre>
<p>The <code>std::convert::From</code> trait allows us to easily convert our FlagsRegister from a <code>u8</code> and back.</p>
<p>Now that we have our special <code>FlagsRegister</code>, we can replace the <code>u8</code> in our <code>Registers</code> struct's <code>f</code> field.</p>
<p>And that's it! We have all the functionality we need for our registers. Next we'll be looking at different instructions for manipulating the registers.</p>
<a class="header" href="#instructions-on-register-data" id="instructions-on-register-data"><h1>Instructions on Register Data</h1></a>
<p>The first instructions we'll be examining are instructions that just operate on and manipulate register data.</p>
<a class="header" href="#add" id="add"><h2>ADD</h2></a>
<p>We'll start by looking closely at how the <code>ADD</code> instructions work. This is a simple instruction that adds specific register's contents to the A register's contents. Once we know how this instruction works, it won't be much work to extend the CPU to support all other instructions that just operate on register data.</p>
<a class="header" href="#definition" id="definition"><h3>Definition</h3></a>
<p>First we need to define the instruction. We'll get into how the game code actually encodes instructions and where the instructions come from later on. For now we're just focusing on the instruction itself and how it affects the CPU registers.</p>
<p>The first thing to do is to define an enum called <code>Instruction</code>. This enum will be the central place where all of our instructions will be defined. Our <code>ADD</code> instruction needs to include information on which register they're targeting so we'll make sure to include it by associating the instruction with <code>ArithmeticTarget</code> enum that specifies the target register. <code>ADD</code> can target all of the 8 bit registers except f.</p>
<pre><code class="language-rust noplaypen">enum Instruction {
  ADD(ArithmeticTarget),
}

enum ArithmeticTarget {
  A, B, C, D, E, H, L,
}
</code></pre>
<a class="header" href="#executing-the-instruction" id="executing-the-instruction"><h3>Executing the Instruction</h3></a>
<p>Ok, now that we have ths instruction, we'll need a way to execute it. Let's create a method on CPU that takes an instruction and executes it. This method will take a mutable reference to the CPU since instructions always mutate the CPU's state. The method will also take the instruction it will execute. We'll pattern match on the instruction and the target register, and then we'll do the appropriate action according to the instruction and the register:</p>
<pre><code class="language-rust noplaypen"># struct CPU {}
# enum Instruction { ADD(ArithmeticTarget), }
# enum ArithmeticTarget { A, B, C, D, E, H, L, }
impl CPU {
  fn execute(&amp;mut self, instruction: Instruction) {
    match instruction {
      Instruction::ADD(target) =&gt; {
        match target {
          ArithmeticTarget::C =&gt; {
            // TODO: implement ADD on register C
          }
          _ =&gt; { /* TODO: support more targets */ }
        }
      }
      _ =&gt; { /* TODO: support more instructions */ }
    }
  }
}
</code></pre>
<p>We now have the boiler plate for figuring out which instruction and which target register. Let's see now what we have to do to the actual CPU. The steps for <code>ADD</code> for 8 bit target registers are the following:</p>
<ul>
<li>Read the current value from the target register</li>
<li>Add the value to the value in the A register making sure to handle overflow properly</li>
<li>Update the flags register</li>
<li>Write the updated value to the A register</li>
</ul>
<p>Let's implement it with C as the target register:</p>
<pre><code class="language-rust noplaypen"># struct Registers { a:u8, c: u8 }
# struct CPU { registers: Registers }
# enum Instruction { ADD(ArithmeticTarget), }
# enum ArithmeticTarget { A, B, C, D, E, H, L, }
impl CPU {
  fn execute(&amp;mut self, instruction: Instruction) {
    match instruction {
      Instruction::ADD(target) =&gt; {
        match target {
          ArithmeticTarget::C =&gt; {
            let value = self.registers.c;
            let new_value = self.add(value);
            self.registers.a = new_value;
          }
          _ =&gt; { /* TODO: support more targets */ }
        }
      }
      _ =&gt; { /* TODO: support more instructions */ }
    }
  }

  fn add(&amp;mut self, value: u8) -&gt; u8 {
    let (new_value, did_overflow) = self.registers.a.overflowing_add(value);
    // TODO: set flags
    new_value
  }
}
</code></pre>
<p>Notice that we use the <code>overflowing_add</code> method on our 8 bit value instead of <code>+</code>. This is because <code>+</code> panics in development when the result of the addition overflows. Rust forces us to be explicit about the behaivor we want, we chose <code>overflowing_add</code> because it properly overflows the value, and it informs us if the addition actually resulted in an overflow or not. This will be important information for when we update the flags register.</p>
<a class="header" href="#setting-flags" id="setting-flags"><h3>Setting Flags</h3></a>
<p>There are four flags defined on the flags register:</p>
<ul>
<li>
<p>Zero: set to true if the result of the operation is equal to 0.</p>
</li>
<li>
<p>Subtract: set to true if the operation was a subtraction.</p>
</li>
<li>
<p>Carry: set to true if the operation resulted in an overflow.</p>
</li>
<li>
<p>Half Carry: set to true if there is an overflow from the lower nibble (a.k.a the lower four bits) to the upper nibble (a.k.a the upper four bits). Let's take a look at some examples of what this means. In the following diagram, we have the byte 143 in binary (0b1000_1111). We then add 0b1 to the number. Notice how the 1 from the lower nibble is carried to the upper nibble. You should already be familiar with carries from elemetry arithmetic. Whenever there's not enough room for a number in a particular digit's place, we carry over to the next digits place.</p>
<pre><code class="language-ignore">      lower nibble            lower nibble
         ┌--┐                    ┌--┐
    1000 1111  +   1   ==   1001 0000
    └--┘                    └--┘
upper nibble            upper nibble
</code></pre>
<p>If this happens when adding our values, we set the half_carry flag to true. We can test for this by masking out the upper nibble of both the A register and the value we're adding and testing if this value is greater than 0xF.</p>
</li>
</ul>
<p>So let's take a look at the code:</p>
<pre><code class="language-rust noplaypen"># struct FlagsRegister { zero: bool, subtract: bool, half_carry: bool, carry: bool }
# struct Registers { a: u8, f: FlagsRegister }
# struct CPU { registers: Registers }
impl CPU {
  fn add(&amp;mut self, value: u8) -&gt; u8 {
    let (new_value, did_overflow) = self.registers.a.overflowing_add(value);
    self.registers.f.zero = new_value == 0;
    self.registers.f.subtract = false;
    self.registers.f.carry = did_overflow;
    // Half Carry is set if adding the lower nibbles of the value and register A
    // together result in a value bigger than 0xF. If the result is larger than 0xF
    // than the addition caused a carry from the lower nibble to the upper nibble.
    self.registers.f.half_carry = (self.registers.a &amp; 0xF) + (value &amp; 0xF) &gt; 0xF;
    new_value
  }
}
</code></pre>
<a class="header" href="#how-do-we-know" id="how-do-we-know"><h2>How Do We Know?</h2></a>
<p>Yout might be wondering, &quot;how do we know what to do given a certain the instruction&quot;. The short answer is that this is just how the chip was specified  and manufactured to worked. We know this because people have either read the original user's manual for the Game Boy's CPU chip (known as a &quot;data sheet&quot;),or they've written test programs for the chip that call specific instructions and see what happens. Luckily you don't need to do this. You can find descriptions of all the instructions <a href="../appendix/instruction_guide/index.html">in the instruction guide</a>.</p>
<blockquote>
<p><em>Side Note</em></p>
<p>Most CPU instructions that deal with register data manipulate that data through various bitwise operations. If the likes of logical shifts and bitwise ands aren't super clear to you, check out the <a href="./appendix/bit_manipulation.html">guide on bit manipulation</a>.</p>
</blockquote>
<p>What are the other types of instructions that act on register data?</p>
<ul>
<li><strong>ADDHL</strong> (add to HL) - just like ADD except that the target is added to the HL register</li>
<li><strong>ADC</strong> (add with carry) - just like ADD except that the value of the carry flag is also added to the number</li>
<li><strong>SUB</strong> (subtract) - subtract the value stored in a specific register with the value in the A register</li>
<li><strong>SBC</strong> (subtract with carry) - just like ADD except that the value of the carry flag is also subtracted from the number</li>
<li><strong>AND</strong> (logical and) - do a bitwise and on the value in a specific register and the value in the A register</li>
<li><strong>OR</strong> (logical or) - do a bitwise or on the value in a specific register and the value in the A register</li>
<li><strong>XOR</strong> (logical xor) - do a bitwise xor on the value in a specific register and the value in the A register</li>
<li><strong>CP</strong> (compare) - just like SUB except the result of the subtraction is not stored back into A</li>
<li><strong>INC</strong> (increment) - increment the value in a specific register by 1</li>
<li><strong>DEC</strong> (decrement) - decrement the value in a specific register by 1</li>
<li><strong>CCF</strong> (complement carry flag) - toggle the value of the carry flag</li>
<li><strong>SCF</strong> (set carry flag) - set the carry flag to true</li>
<li><strong>RRA</strong> (rotate right A register) - bit rotate A register right through the carry flag</li>
<li><strong>RLA</strong> (rotate left A register) - bit rotate A register left through the carry flag</li>
<li><strong>RRCA</strong> (rotate right A register) - bit rotate A register right (not through the carry flag)</li>
<li><strong>RRLA</strong> (rotate left A register) - bit rotate A register left (not through the carry flag)</li>
<li><strong>CPL</strong> (complement) - toggle every bit of the A register</li>
<li><strong>BIT</strong> (bit test) - test to see if a specific bit of a specific register is set</li>
<li><strong>RESET</strong> (bit reset) - set a specific bit of a specific register to 0</li>
<li><strong>SET</strong> (bit set) - set a specific bit of a specific register to 1</li>
<li><strong>SRL</strong> (shift right logical) - bit shift a specific register right by 1</li>
<li><strong>RR</strong> (rotate right) - bit rotate a specific register right by 1 through the carry flag</li>
<li><strong>RL</strong> (rotate left) - bit rotate a specific register left by 1 through the carry flag</li>
<li><strong>RRC</strong> (rorate right) - bit rotate a specific register right by 1 (not through the carry flag)</li>
<li><strong>RLC</strong> (rorate left) - bit rotate a specific register left by 1 (not through the carry flag)</li>
<li><strong>SRA</strong> (shift right arithmetic) - arithmetic shift a specific register right by 1</li>
<li><strong>SLA</strong> (shift left arithmetic) - arithmetic shift a specific register left by 1</li>
<li><strong>SWAP</strong> (swap nibbles) - switch upper and lower nibble of a specific register</li>
</ul>
<p>Reading through the guide on instructions, should give you enough information to implement all the instructions yourself.</p>
<p>Next, we'll be looking at how the CPU keeps track of which instructions to execute as well as different types of instructions that can change where we are in a particular program.</p>
<a class="header" href="#program-counter" id="program-counter"><h1>Program Counter</h1></a>
<p>So far we've seen instructions that can operate on register data. But how does the CPU which instruction to execute? To understand this, we'll first need to understand where our instructions are stored.</p>
<a class="header" href="#game-rom" id="game-rom"><h2>Game ROM</h2></a>
<p>So far we know that the Game Boy has a CPU that executes instructions and it has memory. Memory can be thought of as one very large array of 8-bit numbers.</p>
<p>At the beginning of this very long array are 255 bytes (from index 0x0000 to index 0x00FF) that are hard coded into the Game Boy's circuitry. These 255 bytes are instructions that tell the Game Boy how to &quot;bootstrap&quot; itself (i.e. get itself ready to execute a game) as well as display the <a href="https://www.youtube.com/watch?v=jCfPojZ_xLw">iconic splash screen</a>. Later in the book we'll be looking at specifically what these instructions do, but for now just imagine them as a collection of instructions many of which we learned in the previous chapter and the rest of which we'll learn in this chapter and the next few to come.</p>
<p>When the user of a Game Boy inserts a game cartridge, the contents of that cartridge become available to the CPU right after these 255 bytes. We'll talk later about where other things such as the contents of the screen and graphics data live in memory later in the book. For now we just need to know that the contents of memory starting at index 0x100 until index 0x3FFF include the contents of the cartridge.</p>
<p>So our memory is simply an long array of 8-bit numbers (0xFFFF or 65,536 of them to be exact). Each of these numbers can be decoded as an instruction that our CPU knows how to run. But how does the CPU know which of these to execute?</p>
<a class="header" href="#the-program-counter" id="the-program-counter"><h2>The Program Counter</h2></a>
<p>Along with the register data, our CPU also holds on to a 16-bit number called the progam counter (often abbreviated as PC) which tells us which instruction the Game Boy is currently executing. This 16-bit number is capable of addressing of the of 0xFFFF numbers that live in memory. In fact, when we talk about the memory array we don't usually use the term &quot;index&quot;, but instead the term &quot;address&quot;.</p>
<p>Let's add a program counter to our CPU as well as memory that we can address from the CPU.</p>
<pre><pre class="playpen"><code class="language-rust noplayground">
# #![allow(unused_variables)]
#fn main() {
# struct Registers {}
struct CPU {
  registers: Registers,
  pc: u16,
  bus: MemoryBus,
}

struct MemoryBus {
  memory: [u8; 0xFFFF]
}

impl MemoryBus {
  fn read_byte(&amp;self, address: u16) -&gt; u8 {
    self.memory[address as usize]
  }
}
#}</code></pre></pre>
<p>We now have a program counter that can tell us at which address in memory the currently executing instruction is. We won't talk much more about the contents of memory or where certain things in memory live until later in the book. For now, you should just picture memory as a large array that we can read from.</p>
<p>Now we'll need to actually add the method to the CPU that uses the program counter to read the instruction from memory and execute it.</p>
<p>The full set of steps is as follows:</p>
<ul>
<li>Use the program counter to read the instruction byte from memory.</li>
<li>Translate the byte to one of the instances of the <code>Instruction</code> enum</li>
<li>If we can successfully translate the instruction call our <code>execute</code> method else panic which now returns the next program counter</li>
<li>Set this next program counter on our CPU</li>
</ul>
<pre><pre class="playpen"><code class="language-rust noplayground">
# #![allow(unused_variables)]
#fn main() {
# enum Instruction { }
# struct CPU { pc: u16, bus: Bus }
# struct Bus {}
# impl Bus {
#   fn read_byte(&amp;self, a: u16) -&gt; u8 { 0 }
# }
# impl CPU {
#   fn execute(&amp;self, i: Instruction) -&gt; u16 { 0 }
# }
# impl Instruction {
#   fn from_byte(b: u8) -&gt; Option&lt;Instruction&gt; { None }
# }
impl CPU {
  fn step(&amp;mut self) {
    let mut instruction_byte = self.bus.read_byte(self.pc);

    let next_pc = if let Some(instruction) = Instruction::from_byte(instruction_byte) {
      self.execute(instruction)
    } else {
      panic!(&quot;Unkown instruction found for: 0x{:x}&quot;, instruction_byte);
    };

    self.pc = next_pc;
  }
}
#}</code></pre></pre>
<p>So there's two things we'll need to add for the above to work. We'll need to change our execute method to return the next program counter, and we'll need to add a function that takes a byte and returns an <code>Instruction</code>. Let's start with latter. Decoding our instruction byte as an <code>Instruction</code> is very straight forward. Instructions are uniquely identified by the byte number. For instance, a logical <code>OR</code> with the <code>A</code> register as its target is identified by the byte 0x87. Want to do an <code>OR</code> with the <code>H</code> register as the target? That's the number 0xB4. The <code>SCF</code> (or Set Carry Flag) instruction is identified by the byte 0x37. We can use our <a href="../appendix/instruction_guide/index.html">instruction guide</a> to find out which byte value corresponds to which <code>Instruction</code>.</p>
<pre><pre class="playpen"><code class="language-rust noplayground">
# #![allow(unused_variables)]
#fn main() {
# enum IncDecTarget { BC, DE }
# enum Instruction { INC(IncDecTarget) }
impl Instruction {
  fn from_byte(byte: u8) -&gt; Option&lt;Instruction&gt; {
    match byte {
      0x02 =&gt; Some(Instruction::INC(IncDecTarget::BC)),
      0x13 =&gt; Some(Instruction::INC(IncDecTarget::DE)),
      _ =&gt; /* TODO: Add mapping for rest of instructions */ None
    }
  }
}
#}</code></pre></pre>
<p>And now let's change our <code>execute</code> method so that it now returns the next program counter:</p>
<pre><pre class="playpen"><code class="language-rust noplayground">
# #![allow(unused_variables)]
#fn main() {
# struct Registers { a:u8, c: u8 }
# struct CPU { pc: u16, registers: Registers }
# enum Instruction { ADD(ArithmeticTarget), }
# enum ArithmeticTarget { A, B, C, D, E, H, L, }
impl CPU {
  fn execute(&amp;mut self, instruction: Instruction) -&gt; u16 {
    match instruction {
      Instruction::ADD(target) =&gt; {
        match target {
          ArithmeticTarget::C =&gt; {
            let value = self.registers.c;
            let new_value = self.add(value);
            self.registers.a = new_value;
            self.pc.wrapping_add(1)
          }
          _ =&gt; { /* TODO: support more targets */ self.pc }
        }
      }
      _ =&gt; { /* TODO: support more instructions */ self.pc }
    }
  }
  # fn add(&amp;self, value: u8) -&gt; u8 {
  #   0
  # }
}
#}</code></pre></pre>
<p>Now we have the ability to read the instruction byte from memory that's pointed to by our program counter, decode that instruction byte as one of the variants of our <code>Instruction</code> enum, execute that instruction and get back the new program counter and finally set the new program counter on our CPU. This is how all instructions in the Game Boy get executed! Well, except...</p>
<a class="header" href="#prefix-instructions" id="prefix-instructions"><h2>Prefix Instructions</h2></a>
<p>The process we've laid out for how instructions get executed is true for roughly half of the total instructions the Game Boy can perform. The other half of instructions work the same way except that instead of being identified by a single byte they're first indentified by a prefix byte. This prefix byte tells the CPU, &quot;Hey! The next instruction byte you read shouldn't be interpreted as a normal instruction, but rather as a prefix instruction&quot;.</p>
<p>This prefix byte is the number &quot;0xCB&quot;. So, we'll need to add logic that first checks to see if the byte we read from memory is 0xCB. If it is, we then need to read one more byte and interpret this byte as an &quot;prefix instruction&quot;. For example, if we read 0xCB from memory, we know that we're going to be decoding a prefix instruction. We then read another byte. If that byte is, say, 0xB4, we should <em>not</em> interpret this as <code>OR</code> with <code>H</code> as the target like we normally would but rather as a <code>RES</code> instruction with the 6th bit of the <code>H</code> register as the target. Again we can use the <a href="../appendix/instruction_guide/index.html">instruction guide</a> to help us know what a given byte should decode as.</p>
<p>Let's put it in code!</p>
<pre><pre class="playpen"><code class="language-rust noplayground">
# #![allow(unused_variables)]
#fn main() {
# enum IncDecTarget { BC }
# enum PrefixTarget { B }
# enum Instruction { INC(IncDecTarget), RLC(PrefixTarget) }
# struct CPU { pc: u16, bus: Bus }
# struct Bus {}
# impl Bus { fn read_byte(&amp;self, a: u16) -&gt; u8 { 0 } }
# impl CPU { fn execute(&amp;self, i: Instruction) -&gt; u16 { 0 } }
impl CPU {
  fn step(&amp;mut self) {
    let mut instruction_byte = self.bus.read_byte(self.pc);
    let prefixed = instruction_byte == 0xCB;
    if prefixed {
      instruction_byte = self.bus.read_byte(self.pc + 1);
    }

    let next_pc = if let Some(instruction) = Instruction::from_byte(instruction_byte, prefixed) {
      self.execute(instruction)
    } else {
      let description = format!(&quot;0x{}{:x}&quot;, if prefixed { &quot;cb&quot; } else { &quot;&quot; }, instruction_byte);
      panic!(&quot;Unkown instruction found for: {}&quot;, description)
    };

    self.pc = next_pc;
  }
}

impl Instruction {
  fn from_byte(byte: u8, prefixed: bool) -&gt; Option&lt;Instruction&gt; {
    if prefixed {
      Instruction::from_byte_prefixed(byte)
    } else {
      Instruction::from_byte_not_prefixed(byte)
    }
  }

  fn from_byte_prefixed(byte: u8) -&gt; Option&lt;Instruction&gt; {
    match byte {
      0x00 =&gt; Some(Instruction::RLC(PrefixTarget::B)),
      _ =&gt; /* TODO: Add mapping for rest of instructions */ None
    }
  }

  fn from_byte_not_prefixed(byte: u8) -&gt; Option&lt;Instruction&gt; {
    match byte {
      0x02 =&gt; Some(Instruction::INC(IncDecTarget::BC)),
      _ =&gt; /* TODO: Add mapping for rest of instructions */ None
    }
  }
}
#}</code></pre></pre>
<p>The amount the program counter goes forward after each step of execution is determined by how &quot;wide&quot; the instruction - i.e. how many bytes it takes to describe the instruction in its entirety. For simple instructions, this is one byte - the byte the uniquely identifies the instruction. So far all the instructions we've seen either are 1 or 2 bytes wide (prefix instructions are two bytes - the prefix and the instruction identifier - while the other instructions are only one 1 byte - just for indentifier). In the future we'll see other instructions which have &quot;operands&quot; or data the instruction needs to execute. These instructions can sometimes be even 3 bytes wide.</p>
<p>However, the program counter doesn't have to go forward by a set amount. In fact, there are instructions that manipulate the program counter in arbitrary ways sometimes sending the program counter to somewhere far away from its previous location.</p>
<a class="header" href="#jump-instructions" id="jump-instructions"><h2>Jump Instructions</h2></a>
<p>The real power of computers are their ability to &quot;make decisions&quot; - i.e., do one thing given one condition and do another thing given another condition. At the hardware level this is usually implemented with &quot;jumps&quot; or the ability to change where in our program we are (as indicated by the program counter) based on certain conditions. In the case of the Game Boy's CPU these conditions are specificed by the flags register. For example, there is an instruction that says to &quot;jump&quot; (i.e., set the program counter) to a certain location if the flags register's zero flag is true. This gives the game a way to perform certain instructions and then change to different parts of the game code if the result of the instruction resulted in setting particular flags. Let's list out the types of jumps there:</p>
<ul>
<li>JP: Jump to a particular address dependent on one of the following conditions: the zero flag is true, the zero flag is flase, the carry flag is true, the carry flag is false, or always jump.</li>
<li>JR: Jump a certain amount relative to the current program counter dependent on the same conditions above.</li>
<li>JPI: Jump to the address stored in HI</li>
</ul>
<p>You can find the specifics of how these jump instructions work in the <a href="../appendix/instruction_guide/index.html">instruction guide</a>.</p>
<p>Implementation of jump is pretty trivial:</p>
<pre><code class="language-rust noplaypen"># struct FlagsRegister { zero: bool, carry: bool }
# struct Registers { f: FlagsRegister }
# struct CPU { registers: Registers, bus: Bus, pc: u16 }
# struct Bus {}
# impl Bus { fn read_byte(&amp;self, addr: u16) -&gt; u8 { 0 } }
enum JumpTest {
  NotZero,
  Zero,
  NotCarry,
  Carry,
  Always
}
enum Instruction {
  JP(JumpTest),
}

impl CPU {
  fn execute(&amp;mut self, instruction: Instruction) -&gt; u16 {
    match instruction {
      Instruction::JP(test) =&gt; {
        let jump_condition = match test {
            JumpTest::NotZero =&gt; !self.registers.f.zero,
            JumpTest::NotCarry =&gt; !self.registers.f.carry,
            JumpTest::Zero =&gt; self.registers.f.zero,
            JumpTest::Carry =&gt; self.registers.f.carry,
            JumpTest::Always =&gt; true
        };
        self.jump(jump_condition)
      }
      _ =&gt; { /* TODO: support more instructions */ self.pc }
    }
  }

  fn jump(&amp;self, should_jump: bool) -&gt; u16 {
    if should_jump {
      // Gameboy is little endian so read pc + 2 as most significant bit
      // and pc + 1 as least significant bit
      let least_significant_byte = self.bus.read_byte(self.pc + 1) as u16;
      let most_significant_byte = self.bus.read_byte(self.pc + 2) as u16;
      (most_significant_byte &lt;&lt; 8) | least_significant_byte
    } else {
      // If we don't jump we need to still move the program
      // counter forward by 3 since the jump instruction is
      // 3 bytes wide (1 byte for tag and 2 bytes for jump address)
      self.pc.wrapping_add(3)
    }
  }
}
</code></pre>
<p>It's important to note that the address we jump to is located in the two bytes following the instruction identifier. As the comment in the code example explains, the Game Boy is little endian which means that when you have numbers that are larger than 1 byte, the least significant is stored first in memory and then the most significant byte.</p>
<pre><code class="language-ignore">+-------------+-------------- +--------------+
| Instruction | Least Signif- | Most Signif-
| Identifier  | icant Byte    | icant Byte   |
+-------------+-------------- +--------------+
</code></pre>
<p>We're now succesfully executing instructions that are stored in memory! We learned that the current executing instruction is kept track of by the program counter. We then read the instruction from memory and execute it, getting back our next program counter. With this, we were even able to add some new instructions that let the game conditionally control exactly where the next program counter will be. Next we'll look at bit closer at instructions that read and write to memory.</p>
<a class="header" href="#instructions-for-reading-and-writting-to-memory" id="instructions-for-reading-and-writting-to-memory"><h1>Instructions for Reading and Writting to Memory</h1></a>
<p>Now that we've seen how instructions get executed and the very basics of reading from memory in order to fetch the instructions to be read, we'll look now at instructions that are used to read and write from different parts of memory.</p>
<a class="header" href="#loading-memory" id="loading-memory"><h2>Loading Memory</h2></a>
<p>First, when we talk about reading and writing memory, we usually use the term &quot;load&quot;. We'll be loading data from some place to some place - for example, loading the contents of register A into memory at location 0xFF0A or loading register C with the contents from memory location 0x0040. Loading doesn't have to be between a register and a place in memory, it can also be between two registers or even two places in memory.</p>
<p>All of the instructions we'll be looking are called <code>LD</code> instructions. We'll be differentiating between the types of loads with the <code>LoadType</code> enum. The enum will describe what kind of load we're doing.</p>
<p>Let's take a look at the implementation of the <code>LD</code> instruction with the <code>LoadType</code> of <code>Byte</code> which loads a byte from one place to another.</p>
<pre><code class="language-rust noplaypen"># struct Bus {}
# struct Registers { a: u8 }
# struct CPU { registers: Registers, bus: Bus, pc: u16 }
# impl Registers { fn get_hl(&amp;self) -&gt; u16 { 0 } }
# impl CPU { fn read_next_byte(&amp;self) -&gt; u8 { 0 } }
# impl Bus { fn read_byte(&amp;self, addr: u16) -&gt; u8 { 0 }
             fn write_byte(&amp;self, addr: u16, byte: u8) {} }
enum LoadByteTarget {
    A, B, C, D, E, H, L, HLI
}
enum LoadByteSource {
    A, B, C, D, E, H, L, D8, HLI
}
enum LoadType {
  Byte(LoadByteTarget, LoadByteSource),
}
enum Instruction {
  LD(LoadType),
}

impl CPU {
  fn execute(&amp;mut self, instruction: Instruction) -&gt; u16 {
    match instruction {
      Instruction::LD(load_type) =&gt; {
        match load_type {
          LoadType::Byte(target, source) =&gt; {
            let source_value = match source {
              LoadByteSource::A =&gt; self.registers.a,
              LoadByteSource::D8 =&gt; self.read_next_byte(),
              LoadByteSource::HLI =&gt; self.bus.read_byte(self.registers.get_hl()),
              _ =&gt; { panic!(&quot;TODO: implement other sources&quot;) }
            };
            match target {
              LoadByteTarget::A =&gt; self.registers.a = source_value,
              LoadByteTarget::HLI =&gt; self.bus.write_byte(self.registers.get_hl(), source_value),
              _ =&gt; { panic!(&quot;TODO: implement other targets&quot;) }
            };
            match source {
              LoadByteSource::D8  =&gt; self.pc.wrapping_add(2),
              _                   =&gt; self.pc.wrapping_add(1),
            }
          }
          _ =&gt; { panic!(&quot;TODO: implement other load types&quot;) }
        }
      }
      _ =&gt; { panic!(&quot;TODO: support more instructions&quot;) }
    }
  }
}
</code></pre>
<p>For loads with a register as a source, we simply read the register's value. If the source is a <code>D8</code> (meaning &quot;direct 8 bit value&quot;), the value is stored directly after the instruction, so we can simply call <code>read_next_byte</code> which reads the byte directly after the byte the program counter is currently pointing to. Lastly, if the source is <code>HLI</code> we use the value inside of the <code>HL</code> register as an address from which we read an 8 bit value from memory.</p>
<p>The target is merely the reverse of the source (except that we can't have <code>D8</code> as a target). If the target is a register, we write the source value into that register, and if the target is <code>HLI</code> we write to the address that is stored inside of the <code>HL</code> register.</p>
<p>The use of the 16-bit registers <code>BC</code>, <code>DE</code>, and <code>HL</code> to store addresses is very common.</p>
<p>Let's take a look at the other types of loads that there are:</p>
<ul>
<li><code>Word</code>: just like the <code>Byte</code> type except with 16-bit values</li>
<li><code>AFromIndirect</code>: load the A register with the contents from a value from a memory location whose address is stored in some location</li>
<li><code>IndirectFromA</code>: load a memory location whose address is stored in some location with the contents of the A register</li>
<li><code>AFromByteAddress</code>: Just like <code>AFromIndirect</code> except the memory address is some address in the very last byte of memory.</li>
<li><code>ByteAddressFromA</code>: Just like <code>IndirectFromA</code> except the memory address is some address in the very last byte of memory.</li>
</ul>
<p>For more detail on these instructions checkout the <a href="../appendix/instruction_guide/index.html">instruction guide</a>.</p>
<p>These instructions have been for writing and writing to anywhere in memory, but there are a set of instructions that deal with a specific piece of memory called the stack. Let's take a look at what the stack is and the instructions that are used to manipulate the stack.</p>
<a class="header" href="#the-stack" id="the-stack"><h2>The Stack</h2></a>
<p>Before we can look at the piece of memory in the Game Boy known as the stack, we need to have a good understanding of what a stack is more generally. A stack is a simple data structure that allows you to add values to it (a.k.a &quot;push&quot; values) and then get these values back (a.k.a pop them off the stack). The key thing to remember with a stack is that you pop items off the stack in reverse order from which you pushed the items on - i.e., if you pushed three items &quot;A&quot;, &quot;B&quot;, &quot;C&quot; on to a stack in that order, the order you will get them back when poping them off is &quot;C&quot;, &quot;B&quot;, &quot;A&quot;.</p>
<p>The Game Boy CPU has built in support for a stack like data structure in memory. This stack lives somewhere in memory (we'll talk about how it's location in memory is set in just a minute), and it holds on to 16 bit values. How is it built?</p>
<p>First, the CPU has an additional 16-bit register on it that indicates the top of the stack. This register is called <code>SP</code> or stack pointer because it &quot;points&quot; to where the top of the stack is. Let's add this register to our CPU:</p>
<pre><pre class="playpen"><code class="language-rust noplayground">
# #![allow(unused_variables)]
#fn main() {
# struct Registers {}
# struct MemoryBus {}
struct CPU {
  registers: Registers,
  pc: u16,
  sp: u16,
  bus: MemoryBus,
}
#}</code></pre></pre>
<p>We have a stack pointer now so we know where our stack is, but how do we push and pop from this stack?</p>
<p>The Game Boy's CPU understands two insructions for doing just that. <code>PUSH</code> will write the contents of any 16-bit register into the stack and <code>POP</code> writes the head of stack into any 16-bit register.</p>
<p>Here's what's actually happening when a <code>PUSH</code> is performed:</p>
<ul>
<li><em>Decrease</em> the stack pointer by 1.</li>
<li>Write the most significant byte of the 16 bit value into memory at the location the stack pointer is now pointing to</li>
<li><em>Decrease</em> the stack pointer by 1 again.</li>
<li>Write the least significant byte of the 16 bit value into memory at the location the stack pointer is now pointing to</li>
</ul>
<p>Notice that the stack pointer is decresed by 1 and not increased. This is because the stack grows downward in memory. This is extra helpful since the normal place for the stack to live is at the very end of memory. In a later chapter we'll see that it's actually the Game Boy's boot ROM that sets the stack pointer to the very end of memory. Thus, when the stack grows it grows away from the end of memory towards the beginning of memory.</p>
<p>Let's implement <code>PUSH</code>:</p>
<pre><pre class="playpen"><code class="language-rust noplayground">
# #![allow(unused_variables)]
#fn main() {
# struct Registers { }
# impl Registers { fn get_bc(&amp;self) -&gt; u16 { 0 } }
# struct CPU { pc: u16, bus: Bus, sp: u16, registers: Registers }
# struct Bus {}
# impl Bus { fn write_byte(&amp;self, addr: u16, value: u8) { } }
# enum Instruction { PUSH(StackTarget), }
# enum StackTarget { BC, DE }
impl CPU {
  fn execute(&amp;mut self, instruction: Instruction) -&gt; u16 {
    match instruction {
      Instruction::PUSH(target) =&gt; {
        let value = match target {
          StackTarget::BC =&gt; self.registers.get_bc(),
          _ =&gt; { panic!(&quot;TODO: support more targets&quot;) }
        };
        self.push(value);
        self.pc.wrapping_add(1)
      }
      _ =&gt; { panic!(&quot;TODO: support more instructions&quot;) }
    }
  }

  fn push(&amp;mut self, value: u16) {
    self.sp = self.sp.wrapping_sub(1);
    self.bus.write_byte(self.sp, ((value &amp; 0xFF00) &gt;&gt; 8) as u8);

    self.sp = self.sp.wrapping_sub(1);
    self.bus.write_byte(self.sp, (value &amp; 0xFF) as u8);
  }
}
#}</code></pre></pre>
<p>We can now push elements on to the stack. Here's what's actually happening when a <code>PUSH</code> is performed:</p>
<ul>
<li>Read the least significant byte of the 16 bit value from memory at the location the stack pointer is pointing to</li>
<li><em>Increase</em> the stack pointer by 1.</li>
<li>Read the most significant byte of the 16 bit value from memory at the location the stack pointer is now pointing to</li>
<li><em>Increase</em> the stack pointer by 1 again.</li>
<li>Return the value with the most and least significant byte combined together</li>
</ul>
<p>Let's write <code>POP</code>:</p>
<pre><pre class="playpen"><code class="language-rust noplayground">
# #![allow(unused_variables)]
#fn main() {
# struct Registers { }
# impl Registers { fn set_bc(&amp;self, value: u16) { } }
# struct CPU { pc: u16, bus: Bus, sp: u16, registers: Registers }
# struct Bus {}
# impl Bus { fn read_byte(&amp;self, addr: u16) -&gt; u8 { 0 } }
# enum Instruction { POP(StackTarget), }
# enum StackTarget { BC, DE }
impl CPU {
  fn execute(&amp;mut self, instruction: Instruction) -&gt; u16 {
    match instruction {
      Instruction::POP(target) =&gt; {
        let result = self.pop();
        match target {
            StackTarget::BC =&gt; self.registers.set_bc(result),
            _ =&gt; { panic!(&quot;TODO: support more targets&quot;) }
        };
        self.pc.wrapping_add(1)
      }
      _ =&gt; { panic!(&quot;TODO: support more instructions&quot;) }
    }
  }

  fn pop(&amp;mut self) -&gt; u16 {
    let lsb = self.bus.read_byte(self.sp) as u16;
    self.sp = self.sp.wrapping_add(1);

    let msb = self.bus.read_byte(self.sp) as u16;
    self.sp = self.sp.wrapping_add(1);

    (msb &lt;&lt; 8) | lsb
  }
}
#}</code></pre></pre>
<p>And there we have it! We have a working stack that we can used. But what sort of things is the stack used for? One built in use for the stack is creating a &quot;call&quot; stack that allows the game to &quot;call&quot; functions and return from them. Let's see how that works.</p>
<a class="header" href="#calling-functions" id="calling-functions"><h2>Calling Functions</h2></a>
<p>In most programming languages when you call a function, the state of the calling function is saved somewhere, execution is allowed to happen for the called function, and then when the called function returns, the state of the called function is restored. It turns out the Game Boy has built in support for this mechanism where the state that is saved is simply just what the program counter was when the called function was called. This means we can &quot;call a function&quot; and that function itself can call functions, and when all of that is done, we'll return right back to the place we left off before we called the function.</p>
<p>This functionality is handled by two types of instructions <code>CALL</code> and <code>RET</code> (a.k.a return). The way <code>CALL</code> works is by using a mixture of two instructions we already know about <code>PUSH</code> and <code>JP</code> (a.k.a jump). To execute the <code>CALL</code> instruction, we must do the following:</p>
<ul>
<li><code>PUSH</code> the next program counter (i.e. the program counter we would have if we were not jumping) on to the stack</li>
<li><code>JP</code> (a.k.a jump) to the address specified in the next 2 bytes of memory (a.k.a the function).</li>
</ul>
<p>And that's it! We've called into our function. But what happens when we call <code>RET</code> (a.k.a return) from our called function? Here's what will happen:</p>
<ul>
<li><code>POP</code> the next program counter off the stack and jump back to it.</li>
</ul>
<p>Well that's easy! Let's see it in code:</p>
<pre><pre class="playpen"><code class="language-rust noplayground">
# #![allow(unused_variables)]
#fn main() {
# struct FlagsRegister { zero: bool }
# struct Registers { f: FlagsRegister }
# struct CPU { pc: u16, registers: Registers }
# enum Instruction { CALL(JumpTest), RET(JumpTest)}
# enum JumpTest { NotZero }
# impl CPU {
# fn read_next_word(&amp;self) -&gt; u16 { 0 }
# fn push(&amp;self, value: u16) { }
# fn pop(&amp;self) -&gt; u16 { 0 } }
impl CPU {
  fn execute(&amp;mut self, instruction: Instruction) -&gt; u16 {
    match instruction {
      Instruction::CALL(test) =&gt; {
          let jump_condition = match test {
              JumpTest::NotZero =&gt; !self.registers.f.zero,
              _ =&gt; { panic!(&quot;TODO: support more conditions&quot;) }
          };
          self.call(jump_condition)
      }
      Instruction::RET(test) =&gt; {
          let jump_condition = match test {
              JumpTest::NotZero =&gt; !self.registers.f.zero,
              _ =&gt; { panic!(&quot;TODO: support more conditions&quot;) }
          };
          self.return_(jump_condition)
      }
      _ =&gt; { panic!(&quot;TODO: support more instructions&quot;) }
    }
  }

  fn call(&amp;mut self, should_jump: bool) -&gt; u16 {
    let next_pc = self.pc.wrapping_add(3);
    if should_jump {
      self.push(next_pc);
      self.read_next_word()
    } else {
      next_pc
    }
  }

  fn return_(&amp;mut self, should_jump: bool) -&gt; u16 {
    if should_jump {
      self.pop()
    } else {
      self.pc.wrapping_add(1)
    }
  }
}
#}</code></pre></pre>
<p>Now we can easily call functions and return from them. We're now done with the vast majority of our CPU instructions!</p>
<a class="header" href="#finishing-up-the-cpu" id="finishing-up-the-cpu"><h1>Finishing Up the CPU</h1></a>
<p>We've nearly reached the end of building our CPU. There are a few instructions left to implement, many of which we won't touch on here, since they're closely tied with other parts of the Game Boy that we've yet to talk about.</p>
<a class="header" href="#remaining-instructions" id="remaining-instructions"><h2>Remaining Instructions</h2></a>
<p>In this chapter, we'll look at two more instructions: <code>NOP</code> and <code>HALT</code></p>
<a class="header" href="#nop" id="nop"><h3>NOP</h3></a>
<p><code>NOP</code> is perhaps the simplest of the Game Boy's instructions. It stands for no-operation and it effectively does nothing except advance the program counter by 1.</p>
<a class="header" href="#halt" id="halt"><h3>HALT</h3></a>
<p><code>HALT</code> is a big more complicated than <code>NOP</code>. When the Game Boy is running, it is constantly in a loop executing instructions. The <code>HALT</code> instruction gives the game the ability to stop the CPU from executing any more instructions. How the Game Boy eventually continues executing instructions will be discussed later in the book, but for now, we have the ability to stop the Game Boy dead in its tracks. Reasons a game might want to do this include saving battery. If the game doesn't have anything to do, it can halt the CPU and save a bit energy.</p>
<p>For now, we'll implement <code>HALT</code> by adding a <code>is_halted</code> boolean to the CPU. At the beginning of <code>execute</code> we can check if the CPU is halted. If it is, we simply return. The <code>HALT</code> instruction simply sets this field to true.</p>
<a class="header" href="#where-we-are" id="where-we-are"><h2>Where We Are</h2></a>
<p>So far we've learned about the CPU and the many different instructions that the CPU can execute. We learned that these instructions live in memory which is just a long array of 8-bit numbers. The CPU reads in these bytes, decodes them as instructions and executes them. Some instructions simply do different arithmetic operations on the contents of the CPU's registers. Some instructions can cause the CPU to change its program counters, effectively &quot;jumping&quot; it to a different place in the game code. Some instructions read from and write to memory including a special part of memory we call the stack which behaves like a stack data structure. Finally, we learned about two special instructions: <code>NOP</code> which does nothing and <code>HALT</code> which stops the CPU from executing more instructions.</p>
<p>In the next section of the book, we'll be leaving the comfort of the CPU and exploring memory more closely.</p>
<a class="header" href="#graphics" id="graphics"><h1>Graphics</h1></a>
<p>Up until this point, we've been reading and writting to memory and performing different operations in the CPU. Our CPU has lots of work that it is capable of doing and in many senses it can already 'run' games. But, of course, one of the main things that defines a video game is the video or graphics aspect of it.</p>
<p>In the next section of the book, we'll be deep diving into how graphics work in the Game Boy. First, we'll start with how the Game Boy's background graphics work. This will be enough for us to get the iconic boot screen displaying. Once we're done with this, we'll move on to sprite graphics that allow things like characters and enemies to appear.</p>
<p>So without further delay, let's get started!</p>
<a class="header" href="#tile-ram" id="tile-ram"><h1>Tile Ram</h1></a>
<p>Before we can display background graphics to the screen, we have to have a good understanding of how background graphics actually work and where those graphics are stored in memory.</p>
<p>Game Boy games do not have direct control over what appears in the background. This is because the Game Boy is limited in how much it can store for graphics. The Game Boy has 0x1FFF (8191) bytes worth of storage for background graphics. Unlike more modern systems that employ a direct &quot;frame buffer&quot; (i.e., a long array of bytes where each byte or set of bytes describes how a corresponding pixel should be displayed on screen), the Game Boy uses a tiling system. This system allows the game to build 8 pixel by 8 pixel tiles and then place each tile on the screen at a certain index.</p>
<p>TODO: Graphic showing the difference between the two</p>
<a class="header" href="#creating-tiles" id="creating-tiles"><h2>Creating Tiles</h2></a>
<p>So before we look at how pixels on the screen are shown, we first have to see how games manipulate and store tiles.</p>
<p>As we've seen before in our overview of the memory map of the Game Boy, tile data is stored between 0x8000 and 0x97FF (0x1800 or 6144 bytes worth of memory). This area actually contains two seperate tile sets. This allows the game to very quickly switch between two differnt graphic styles without having to switch the tiles out in the time between two screens. We'll explore how the game switches between the two tile sets a bit later.</p>
<p>For now, we'll be focusing on the first tile set in memory that resides at 0x8000 to 0x8FFF (for a total of 0x1000 or 4096 bytes worth of data). Each tile is encoded in 16 bytes (we'll talk about exactly what this encoding looks like below). So if we 0x1000 bytes worth of memory and each tile is encoded in 16 bytes, then we have 0x1000 / 0x10 or 0x100 (256) different tiles.</p>
<p>An observant reader might wonder why the first tile set takes up 0x1000 of the 0x1800 or two thirds worth of space alloted for tile memory. The truth is that the second tile set starts at 0x8800 and goes to 0x97FF. The chunk between 0x8800 and 0x8FFF is therefore shared by the two tile sets.</p>
<p>TODO: Make nicer chart</p>
<pre><code class="language-ignore">8000-87FF: First part of tile set #1
8800-8FFF: Second part of tile set #1
           First part of tile set #2
9000-97FF: Second part of tile set #2
</code></pre>
<p>So how are each of the tiles encoded? First, we need to understand how many different colors a pixel of the Game Boy can display. The Game Boy is capable of displaying 4 different colors: white, light gray, dark gray, and black. The minimal number of bits that we need to encode this information is 2 bits since two bits can encode 4 different numbers: 0b00, 0b01, 0b10, and 0b11.</p>
<blockquote>
<blockquote>
<p><em>Learn More</em></p>
<p>The way the Game Boy hardware displays the 4 different colors is simply by emitting 4 different levels of white light. For &quot;white&quot; for instance the light is fully on, while for black the light is fully off. Light and dark gray are at 33% light and 66% light respectively. In fact, calling these colors white, gray and black isn't really true since the screen of the original Game Boy was green so the colors players see are actually shades of green.</p>
</blockquote>
</blockquote>
<p>The bit value to color mapping is as follows:</p>
<pre><code class="language-ignore">+------+------------+
| 0b11 | white      |
| 0b10 | dark-gray  |
| 0b01 | light-gray |
| 0b00 | black      |
+------+------------+
</code></pre>
<p>So each pixel of our 8x8 pixel (i.e., 64 pixels in total) tile will take 2 bits to represent. That means we'll need 64 * 2 or 128 bits total to represent all the pixels. In terms of number of bytes that's 128 / 8 or 16 bytes total as we've said above.</p>
<p>So this shouldn't be too hard to encode right? Just start from the top left most pixel and every two bits we encode that pixels value right? Unfortunately not. The actual encoding scheme is a little bit more complicated.</p>
<p>Each row of a tile is 2 bytes worth of data (8 pixels with 2 bits per pixel equals 16 bits or 2 bytes). Instead of each pixels value coming one after the other, each pixel is split between the two bytes. So the first pixel is encoded with the left most (i.e., most significant bit a.k.a bit 7) of each byte.</p>
<p>For example, let's imagine that the first two bytes of our tile set memory were 0xB5 (0b10110101) and 0x65 (0b01100101). These two bytes together will encode the data for the first tile. Byte 1 contains the value of the upper (a.k.a most significant) bit and byte 2 contains the value of the lower (least significant) bit.</p>
<p>Let's take a look at how this looks. In the following diagram that colors are represented by 1 letter &quot;B&quot; for black, &quot;D&quot; for dark-gray, &quot;L&quot; for light-gray and &quot;W&quot; for white.</p>
<pre><code class="language-ignore">              Bit Position
A            7 6 5 4 3 2 1 0
d          +-----------------+
d  0x8000  | 1 0 1 1 0 1 0 1 |
r          |-----------------|
e  0x8001  | 0 1 1 0 0 1 0 1 |
s          +-----------------+
s            D L W D B W B W
                 Color
</code></pre>
<p>Since reading the tile data happens much more often than writing it, we can store the tile data internally in a more friendly way.</p>
<p>Let's write some code to see what we need. First, we're going to create a new struct that will be responsible for all the graphics needs of the Game Boy. This loosely mimics the set up of actual hardware where the CPU knows nothing about graphics and all. There's no one chip responsible for graphics instead there is dedicated video RAM and the screen hardware. It would over complicate things if we tried to too closely mimic this set up. Instead we'll create the <code>GPU</code> or &quot;Graphic Processing Unit&quot; to model all of our video needs.</p>
<p>For now, our GPU will hold on to video RAM and our tile set data. Our video ram is just a long array which holds on to raw byte values. The tile set will also be an array of tiles. A tile is simply an array of 8 rows where a row is an array of 8 <code>TileValue</code>s.</p>
<pre><pre class="playpen"><code class="language-rust noplayground">
# #![allow(unused_variables)]
#fn main() {
const VRAM_BEGIN: usize = 0x8000;
const VRAM_END: usize = 0x9FFF;
const VRAM_SIZE: usize = VRAM_END - VRAM_BEGIN + 1;

#[derive(Copy,Clone)]
enum TilePixelValue {
    Zero,
    One,
    Two,
    Three,
}

type Tile = [[TilePixelValue; 8]; 8];
fn empty_tile() -&gt; Tile {
    [[TilePixelValue::Zero; 8]; 8]
}

struct GPU{
    vram: [u8; VRAM_SIZE],
    tile_set: [Tile; 384],
}
#}</code></pre></pre>
<p>Let's go back to our memory bus to redirect any of writes in memory to our video ram to go to the GPU:</p>
<pre><pre class="playpen"><code class="language-rust noplayground">
# #![allow(unused_variables)]
#fn main() {
# const VRAM_BEGIN: usize = 0x8000;
# const VRAM_END: usize = 0x9FFF;
# struct GPU { }
# impl GPU { fn read_vram(&amp;self,addr: usize) -&gt; u8 { 0 }
             fn write_vram(&amp;self, addr: usize, value: u8) {  } }
# struct MemoryBus { gpu: GPU }

impl MemoryBus {
    fn read_byte(&amp;self, address: u16) -&gt; u8 {
        let address = address as usize;
        match address {
            VRAM_BEGIN ... VRAM_END =&gt; {
                self.gpu.read_vram(address - VRAM_BEGIN)
            }
            _ =&gt; panic!(&quot;TODO: support other areas of memory&quot;)
        }
    }

    fn write_byte(&amp;self, address: u16, value: u8) {
        let address = address as usize;
        match address {
            VRAM_BEGIN ... VRAM_END =&gt; {
                self.gpu.write_vram(address - VRAM_BEGIN, value)
            }
            _ =&gt; panic!(&quot;TODO: support other areas of memory&quot;)
        }
    }
}
#}</code></pre></pre>
<p>Notice how from the <code>MemoryBus</code> we don't directly access the vram but instead go through two methods <code>read_vram</code> and <code>write_vram</code>. This is so we can easily cache our tile set in the <code>tile_set</code> field of our CPU. Let's take a look at how these are implemented.</p>
<p><code>read_vram</code> is very simple as it actually just reads from the vram array:</p>
<pre><pre class="playpen"><code class="language-rust noplayground">
# #![allow(unused_variables)]
#fn main() {
# struct GPU { vram: Vec&lt;u8&gt; }
impl GPU {
  fn read_vram(&amp;self, address: usize) -&gt; u8 {
    self.vram[address]
  }
}
#}</code></pre></pre>
<p>However, <code>write_vram</code> is much more involved. Let's take a look at the code and go line by line to see what's happening:</p>
<pre><pre class="playpen"><code class="language-rust noplayground">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Copy,Clone)]
# enum TilePixelValue { Three, Two, One, Zero }
# struct GPU { vram: Vec&lt;u8&gt;, tile_set: [[[TilePixelValue; 8]; 8]; 384]  }
impl GPU {
    fn write_vram(&amp;mut self, index: usize, value: u8) {
        self.vram[index] = value;
        // If our index is greater than 0x1800, we're not writing to the tile set storage
        // so we can just return.
        if index &gt;= 0x1800 { return }

        // Tiles rows are encoded in two bytes with the first byte always
        // on an even address. Bitwise ANDing the address with 0xffe
        // gives us the address of the first byte.
        // For example: `12 &amp; 0xFFFE == 12` and `13 &amp; 0xFFFE == 12`
        let normalized_index = index &amp; 0xFFFE;

        // First we need to get the two bytes that encode the tile row.
        let byte1 = self.vram[normalized_index];
        let byte2 = self.vram[normalized_index + 1];

        // A tiles is 8 rows tall. Since each row is encoded with two bytes a tile
        // is therefore 16 bytes in total.
        let tile_index = index / 16;
        // Every two bytes is a new row
        let row_index = (index % 16) / 2;

        // Now we're going to loop 8 times to get the 8 pixels that make up a given row.
        for pixel_index in 0..8 {
            // To determine a pixel's value we must first find the corresponding bit that encodes
            // that pixels value:
            // 1111_1111
            // 0123 4567
            //
            // As you can see the bit that corresponds to the nth pixel is the bit in the nth
            // position *from the left*. Bits are normally indexed from the right.
            //
            // To find the first pixel (a.k.a pixel 0) we find the left most bit (a.k.a bit 7). For
            // the second pixel (a.k.a pixel 1) we first the second most left bit (a.k.a bit 6) and
            // so on.
            //
            // We then create a mask with a 1 at that position and 0s everywhere else.
            //
            // Bitwise ANDing this mask with our bytes will leave that particular bit with its
            // original value and every other bit with a 0.
            let mask = 1 &lt;&lt; (7 - pixel_index);
            let lsb = byte1 &amp; mask;
            let msb = byte2 &amp; mask;

            // If the masked values are not 0 the masked bit must be 1. If they are 0, the masked
            // bit must be 0.
            //
            // Finally we can tell which of the four tile values the pixel is. For example, if the least
            // significant byte's bit is 1 and the most significant byte's bit is also 1, then we
            // have tile value `Three`.
            let value = match (lsb != 0, msb != 0) {
                (true, true) =&gt; TilePixelValue::Three,
                (false, true) =&gt; TilePixelValue::Two,
                (true, false) =&gt; TilePixelValue::One,
                (false, false) =&gt; TilePixelValue::Zero,
            };

            self.tile_set[tile_index][row_index][pixel_index] = value;
        }

    }
}
#}</code></pre></pre>
<p>We now have a cache of our tile ram so that not only do we have the information directly in VRAM but we also have it in a more accessible format.</p>
<p>Next we'll get into the details of rendering.</p>
<a class="header" href="#memory-map" id="memory-map"><h1>Memory Map</h1></a>
<p>Up until now we've been treating the Game Boy's memory as one long array with 0xFFFF entries in it. While this was a helpful simplification for our work on the CPU (which doesn't know anything more about memory than that), in reality things are bit more complex. Sections of memory are actually used for very specific purposes. In fact there are parts of &quot;memory&quot; that are not actually backed by a RAM chip but instead are directly tied to things like the Game Boy screen or the Game Boy's audio device. Below we'll be &quot;mapping&quot; out memory and talking at a high level about what the different sections of the Game Boy's memory map do. We'll start at the very beginning of memory with address 0x0000 and work our way all the up to the top. This chapter should serve as the jumping off point for the rest of the book, so if you don't understand exactly how something works don't worry, we'll be going in much more detail later on.</p>
<a class="header" href="#a0x0000---0x00ff-boot-rom" id="a0x0000---0x00ff-boot-rom"><h2>0x0000 - 0x00FF: Boot ROM</h2></a>
<p>When the Game Boy first boot's the very bottom 256 bytes of memory is occuppied with the boot ROM. We've talked a little bit about the boot ROM before - how it's responsible for bootstrapping the Game Boy to be able to run a game as well as for playing the <a href="https://www.youtube.com/watch?v=jCfPojZ_xLw">iconic splash screen</a> on boot. Later in the book, we'll be examining the boot ROM very closely.</p>
<a class="header" href="#a0x0000---0x3fff-game-rom-bank-0" id="a0x0000---0x3fff-game-rom-bank-0"><h2>0x0000 - 0x3FFF: Game ROM Bank 0</h2></a>
<p>Once the Game Boy is done booting, it unmaps the boot ROM from memory so it is no longer available. From this point the area once occupied by the boot ROM all the way up to address 0x3FFF is occupied by game code loaded in from the cartridge. Inside of this memory are two areas worth noting:</p>
<ul>
<li>0x0000 - 0x00FF - the area once occupied by the Boot ROM now holds memory called the &quot;Interrupt Table&quot;. We'll be talking at length in the future about interrupt's, but for now the best way to think about them is just like &quot;events&quot; in higher level programming. When specific things happen the hardware automatically looks inside the interrupt table at specific locations for how to handle those events.</li>
<li>0x0100 - 0x014F - This area is known as the cartridge header area. It contains data about the cartridge that was loaded into Game Boy including its name, the size of cartridge ROM and even the nintendo logo. We'll talk about more about the contents of the cartridge when we talk about the boot ROM since it directly references this header area. If you want to really dive into specifics checkout <a href="./appendix/cartridge_header.html">the cartridge header guide</a></li>
</ul>
<p>After these special areas is plain game code. The reason this area is refered to as Bank 0 is explained in the next section.</p>
<a class="header" href="#a0x4000---0x7fff-game-rom-bank-n" id="a0x4000---0x7fff-game-rom-bank-n"><h2>0x4000 - 0x7FFF: Game ROM Bank N</h2></a>
<p>Game ROMs can be quite large - much larger than what can fit into the memory area available. To handle this, the Game Boy allows for ROM &quot;bank switching&quot;. A ROM bank is simply a chunk of the cartirdge ROM. The game can switch in these chunks at run time into the area between 0x4000 - 0x7FFF. The first bank, bank 0, is always the same memory and cannot be switched out. Only the area of memory between 0x4000 and 0x7FFF is capable of being switched out. Later in the book we'll go into specifics of how this works.</p>
<a class="header" href="#a0x8000---0x97ff-tile-ram" id="a0x8000---0x97ff-tile-ram"><h2>0x8000 - 0x97FF: Tile RAM</h2></a>
<p>This area of memory contains data about the graphics that can be displayed to the screen. The Game Boy uses a tiling system for grapics meaning that a game doesn't control the specific pixels that get drawn to the screen, at least not directly. Instead, the game creates a set of tiles which are square chunks of pixels. It can then place these tiles on the screen. So instead of saying &quot;draw pixel 438 light green&quot;, it first says &quot;create a tile with these pixels values&quot; and then later &quot;place that tile I made earlier in positon 5&quot;. The placement of tiles at certain positions happens in the next chunk of memory...</p>
<a class="header" href="#a0x9800---0x9fff-background-map" id="a0x9800---0x9fff-background-map"><h2>0x9800 - 0x9FFF: Background Map</h2></a>
<p>As we described above, the Game Boy uses a tiling system for graphics. In memory 0x8000 to 0x97FF the game creates different tiles. These tiles however don't show up on screen. That happens in this section of memory where the game can map tiles to sections of the screen.</p>
<a class="header" href="#a0xa000---0xbfff-cartridge-ram" id="a0xa000---0xbfff-cartridge-ram"><h2>0xA000 - 0xBFFF: Cartridge RAM</h2></a>
<p>Cartridges (being physical devices) sometimes had extra RAM on them. This gave games even more memory to work with. If the cartridge had this extra RAM the Game Boy automatically mapped the RAM into this area of memory.</p>
<a class="header" href="#a0xc000---0xdfff-working-ram" id="a0xc000---0xdfff-working-ram"><h2>0xC000 - 0xDFFF: Working RAM</h2></a>
<p>This is the RAM that the Game Boy allows a game to use. Our idea of RAM really just being a plain old array where the game could read and write bytes to really only applies to this section of memory.</p>
<a class="header" href="#a0xe000---0xfdff-echo-ram" id="a0xe000---0xfdff-echo-ram"><h2>0xE000 - 0xFDFF: Echo RAM</h2></a>
<p>This section of memory directly mirrors the working RAM section - meaning if you write into the first address of working RAM (0xC000), the same value will appear in the first spot of echo RAM (0xE000). Nintendo actively discouraged developers from using this area of memory and as such we can just pretend it doesn't exist.</p>
<a class="header" href="#a0xfe00---0xfe9f-oam-object-atribute-memory" id="a0xfe00---0xfe9f-oam-object-atribute-memory"><h2>0xFE00 - 0xFE9F: OAM (Object Atribute Memory)</h2></a>
<p>This area of memory contains the description of graphical sprites. The tiles we talked about above were used for backgrounds and levels but not for characters, enemies or objects the user interacted with. These entities, known as sprites, have extra capabilties. The description for how they should look lives here.</p>
<a class="header" href="#a0xfea0---0xfeff-unused" id="a0xfea0---0xfeff-unused"><h2>0xFEA0 - 0xFEFF: Unused</h2></a>
<p>This area is completely unmapped: reading from it just returns 0s and writing to it does nothing.</p>
<a class="header" href="#a0xff00---0xff7f-io-registers" id="a0xff00---0xff7f-io-registers"><h2>0xFF00 - 0xFF7F: I/O Registers</h2></a>
<p>This is one of the most dense areas of memory. Practically every byte has a special meaning. It's used by both the screen and the sound system to determine different settings. We'll be talking a lot about this in the future.</p>
<a class="header" href="#a0xff80---0xfffe-high-ram-area" id="a0xff80---0xfffe-high-ram-area"><h2>0xFF80 - 0xFFFE: High RAM Area</h2></a>
<p>This area is also just normal RAM but is used a lot because some of the <code>LD</code> instructions we've already seen can easily target this area in memory. This area is also sometimes used for the stack, but the top of working RAM is also used for this purpose.</p>
<a class="header" href="#a0xffff-interrupt-enabled-register" id="a0xffff-interrupt-enabled-register"><h2>0xFFFF: Interrupt Enabled Register</h2></a>
<p>The very last byte of memory has special meaning used for handling interrupt events. We'll be looking at this closely later in the book.</p>
<p>Now that we have an idea of what all the areas of memory are used for we can start diving more in detail. The first area we'll be looking at is at tile RAM and the background map along with a few of the I/O registers that will help us finally get some graphics on a screen!</p>
<a class="header" href="#appendix" id="appendix"><h1>Appendix</h1></a>
<a class="header" href="#numbers-in-computers" id="numbers-in-computers"><h1>Numbers in Computers</h1></a>
<p>In this guide, we'll look at how numbers are stored in the Gameboy's CPU, RAM, and ROM. In this guide we'll be using different types of number notations: binary, decimal and hexadecimal. If you're unfamiliar with these different ways of writing numbers, check out our <a href="./number_notations.html">guide on number notations</a>.</p>
<a class="header" href="#bits" id="bits"><h2>Bits</h2></a>
<p>At a very basic level, computers can only read and write two different values that we'll call 1 and 0. This piece of data is called a bit. Computer memory is really just a long array of bits that the computer can read or write.</p>
<blockquote>
<p><strong>Learn More</strong></p>
<p>Computers normally represent bits as either one voltage (e.g., five volts) or as some other, typically lower, voltage (e.g., zero volts). Again, a great resource for learning about how computers actually deal with bits, check out Ben Eater's series on <a href="https://www.youtube.com/user/eaterbc">making an 8-bit Breadboard Computer</a>.</p>
</blockquote>
<p>Bits can represent only two different values 0 or 1. If we want to numbers larger than one we need to compose bits together. To get to three for instance we would write 0b11. The total count of numbers we can represent is equal to 2^(# of bits). So one bit can represent 2^1 a.k.a two numbers and 7 bits can represent 2^7 a.k.a 128 numbers.</p>
<p>Since being able to manipulate numbers larger than 1 is pretty useful, we normally talk about and the computer typically reads and writes bits in large chunks called bytes.</p>
<a class="header" href="#bytes" id="bytes"><h3>Bytes</h3></a>
<p>Bytes are defined as a collection of 8 bits. Our Gameboy, as an 8-bit machine, typically deals with one byte at a time and each compartment in memory stores one byte. However, the Game Boy also has 16-bit instructions which act on two bytes at a time. A byte can represent numbers 2^8 a.k.a 256 numbers (0 to 255) while 8 bytes (composed of 64 bits) and can represent 2^64 a.k.a 9,223,372,036,854,775,808 numbers (0 to 9,223,372,036,854,775,807).</p>
<blockquote>
<p><strong>Learn More</strong></p>
<p>Some times we'll actually only deal with half a byte (i.e., 4 bits) at a time. This is usually referred to as a &quot;nibble&quot;.</p>
</blockquote>
<p>Since writing out bytes in binary can be quite tedious, we normally write out bytes in hexadecimal notation: So while we could write out the byte representing the number 134 as &quot;0b10000110&quot; we typically write it as &quot;0x86&quot;. These two notations specify the same number, &quot;0x86&quot; is just shorter so it's more often used.</p>
<p>When disucssing numbers composed of multiple bytes, for example 0xFFA1 (composed of three bytes), we'll often need to talk about which byte is &quot;most significant&quot; (MSB - most significant byte) and which is &quot;least significant&quot; (LSB - least significant byte). Going back to math class, you may remember that when writing numbers like &quot;178&quot;, the digit on the right (i.e., the &quot;8&quot;) is the least sigificant, it adds the least amount to the total sum of the number (just eight) while the digit on the left (i.e., the &quot;1&quot;) is the most significant since it adds the most to the sum of the number (one hundred!). Bytes work the same way - in 0xFFA1, 0xFF is the most significant byte and 0xA1 is the least significant.</p>
<a class="header" href="#endianess" id="endianess"><h2>Endianess</h2></a>
<p>Let's take the example of two bytes sitting next to each other in memory: first at address 0 there is 0xFF and then at address 1 there is 0x16. If we want to read these two bytes together as a 16 bit number, should it be read as 0xFF16 or as 0x16FF? Even if one way or the other makes more sense to you, the answer is: it depends on the machine. In the case of the Game Boy the order is 0xFF16 - in other words the least significant byte is first in memory. This scheme is known as little-endian and its opposite is known as big-endian.</p>
<a class="header" href="#signed-numbers" id="signed-numbers"><h3>Signed Numbers</h3></a>
<p>Ok so we know how to conceivably represent any number from 0 to some very large positive number. We can just keep adding bytes until we have enough to represent our number. But what about negative numbers? Well one way we could chose to do it (and the way the Game Boy does it) is using something called the &quot;two's complement&quot;.</p>
<p>Let's say we have the number 0b00111011 a.k.a. 59 and we want to represent -59 instead. In two's complement, we do the following:</p>
<ul>
<li>Invert every digit - 1s become 0s and 0s become 1s
<ul>
<li>0b00111011 becomes 0b11000100</li>
</ul>
</li>
<li>Add 1 to the number
<ul>
<li>0b11000100 becomes 0b11000101</li>
</ul>
</li>
</ul>
<p>So -59 is 0b11000101. But wait is 0b11000101 already 197? Yes it is! Whether we chose to interpret a byte as a number from 0 to 255 or as two's complement number capable of representing -128 to 127 is up to programmer! Interpreting a number as only positive means it is &quot;unsigned&quot; and interpeting as being possibly negative with two's complement means it is &quot;signed&quot;.</p>
<a class="header" href="#overflow-and-underflow" id="overflow-and-underflow"><h3>Overflow and underflow</h3></a>
<p>When doing arithmetic on numbers, sometimes the result is too large or small to be represented. For example if you add two 8 bit numbers 253 and 9 together you would expect to get 262. But 262 cannot be represented by 8 bits (it requires 9 bits). When this happens the number simply is what the first 8 bits of 262 would be just with the final 9th bit missing: 0b0000_0110 a.k.a 6. This phenomenon is called overflow. The opposite can occur when subtracting. This is called underflow</p>
<a class="header" href="#rust" id="rust"><h3>Rust</h3></a>
<p>In Rust, the various number types tell us both how many bits are used to represent that particular integer and whether the integer is in two's complement or not. For example, the number type <code>u8</code> is a number composed of 8 bits (i.e., 1 byte) and is unsigned while <code>i64</code> is a number composed of 64 bits (i.e., 8 bytes) and is signed.</p>
<a class="header" href="#number-notations" id="number-notations"><h1>Number Notations</h1></a>
<p>In this guide we'll deal with the various ways that we can think about and write down numbers.</p>
<a class="header" href="#number-notations-1" id="number-notations-1"><h2>Number Notations</h2></a>
<a class="header" href="#binary" id="binary"><h3>Binary</h3></a>
<p>The smallest amount of data that computers, including the Game Boy, deal with are bits. A bit is either one of two values. When we talk about bits we say that a bit is one of two distinct values: &quot;1&quot; or &quot;0&quot;. Bits in other words are &quot;binary&quot; (i.e. relating to, composed of, or involving two things - &quot;bi&quot; is a latin prefix meaning two).</p>
<p>So we can talk about bits by using either the symbol &quot;1&quot; or the symbol &quot;0&quot;. This way of talking about numbers is called &quot;binary notation&quot;. This is different from the way we normally talk about numbers where we have ten different possibilities composed of ten distinct symbols: &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, or &quot;9&quot; - a.k.a. decimal notation (&quot;deci&quot; is a latin prefix meaning ten). When talking binary we'll never need any other symbols besides &quot;0&quot; and &quot;1&quot;.</p>
<blockquote>
<p><strong>Side Note</strong></p>
<p>We don't <em>have</em> to use the symbols &quot;1&quot; and &quot;0&quot; for binary. People sometimes use other ways of representing the two distinct values including: &quot;yes&quot; or &quot;no&quot;, true or false, on or off, high or low, and more! In fact, computers normally represent bits as either one voltage (e.g. five volts) or as some other, typically lower, voltage (e.g. zero volts). Again, a great resource for learning about how computers actually deal with bits, check out Ben Eater's series on <a href="https://www.youtube.com/user/eaterbc">making an 8-bit Breadboard Computer</a>.</p>
</blockquote>
<p>So in binary notation we can represent the number zero with the symbol &quot;0&quot; and the number one with the symbol &quot;1&quot;. What if we want to represent the number two? We just said we don't have the symbol &quot;2&quot; in binary - we only have either &quot;1&quot; or &quot;0&quot;. Well let's think about what we do in our &quot;normal&quot; decimal system when we run out of symbols to use? In other words what happens when we're going from nine (represented by &quot;9&quot;) to ten? Well, we reset the first digit to &quot;0&quot; and add a new one starting with &quot;1&quot;  and we end up with &quot;10&quot; for ten.</p>
<p>This is exactly what we do in binary. So, to represent the number two, we reset the first digit to &quot;0&quot; and a &quot;1&quot; to the left of it. The number two is therefore &quot;10&quot;.</p>
<p>So what's the number three then? You guessed it! &quot;11&quot;. Let's count to ten in binary!</p>
<p>Zero   &quot;0&quot;
One    &quot;1&quot;
Two    &quot;10&quot;
Three  &quot;11&quot;
Four   &quot;100&quot;
Five   &quot;101&quot;
Six    &quot;110&quot;
Seven  &quot;111&quot;
Eight  &quot;1000&quot;
Nine   &quot;1001&quot;
Ten    &quot;1010&quot;</p>
<p>We can now count as high as we want in binary!</p>
<p>Since binary numbers can look an awful lot like decimal numbers, it's helpful to have a way to say &quot;this number is written in binary not in decimal!&quot;. A common way this is done (and how both we will do it in this book and how Rust also does it) is by prefixing numbers written in binary with &quot;0b&quot;. So, the number three would be written &quot;0b11&quot;</p>
<blockquote>
<p><strong>Side Note</strong></p>
<p>In order to avoid confusion, the best way to read binary numbers outloud (or in your head) is by reading each digit instead of using the decimal name for the number. So the number &quot;0b1001&quot; should either be read as &quot;nine&quot; or as &quot;one zero zero one&quot; never as &quot;one thousand and one&quot;.</p>
</blockquote>
<a class="header" href="#hexadecimal" id="hexadecimal"><h3>Hexadecimal</h3></a>
<p>One interesting and important thing to note is at what numbers we add an extra digit when using binary. Let's list them: two, four, eight, sixteen, etc. Can you spot the pattern? Each number is a power two! Another way to call a counting system that works like this is a &quot;base two&quot; counting system. Our decimal system on the other hand gains a digit at every number that is a power of ten - so it is a &quot;base ten&quot; counting system.</p>
<p>The natural question might arise: &quot;are there any other types of counting systems besides base two and base ten&quot;. And the answer is yes! While there are many different systems, the only other one we'll make use of in our emulator is hexadecimal - base sixteen!</p>
<p>So, base two has two different symbols and base ten has ten different symbols, which means base sixteen should have sixteen different symbols. And here they are: &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;. So, instead of writing &quot;10&quot; for ten, we would now write &quot;a&quot; and eleven would be &quot;b&quot; and so on. Once we run out of symbols (i.e. after fifteen - &quot;f&quot;), we do what we've always done: reset our number to &quot;0&quot; and add a digit. Sixteen is written &quot;10&quot;.</p>
<p>Just like how in binary, we use &quot;0b&quot; to make it obvious we're talking binary and not decimal, we use &quot;0x&quot;for hexdecimal. So &quot;0x18&quot; is twenty-four not eighteen.</p>
<a class="header" href="#bit-and-byte-manipulation" id="bit-and-byte-manipulation"><h1>Bit and Byte Manipulation</h1></a>
<p>In this guide, we'll be discussing bit and byte manipulation through different bit-wise operators. If you're a little rusty on bits, bytes, binary and hexadecimal, check out our <a href="./number_notations.html">guide on number notation</a> and our <a href="./numbers.html">guide on numbers</a></p>
<p>CPUs normally do very simple operations on their registers. Most of these operations should be familiar to everyone, but some involve manipulating the bits of a byte in some structured way. Let's take a look.</p>
<a class="header" href="#and-" id="and-"><h2>AND (&amp;)</h2></a>
<p>Bitwise AND (&amp;) is similiar to the boolean AND (&amp;&amp;) operator you're probably already familiar with except that it operates on each bit of a byte or set of bytes. It's important to remember that boolean values are equivalent to a single bit: 1 is true and 0 is false.</p>
<p>If we have two boolean values we already know how to AND them:</p>
<pre><code class="language-ignore">true  &amp;&amp; true  == true
false &amp;&amp; true  == false
true  &amp;&amp; false == false
false &amp;&amp; false == false
</code></pre>
<p>For bitwise operators we simply do the same operation on the the bits of two numbers that are the same digit place. If we encounter a <code>1</code> and <code>1</code> it becomes <code>1</code>. All other combinations are <code>0</code>.</p>
<p>Let's take a look at an example:</p>
<pre><code class="language-ignore">  1001
&amp; 1100
------
  1000
</code></pre>
<p>Of course, we can do the same thing with hexadecimal numbers. The best way to think of these when you're getting used to them is to convert the hexadecimal number to binary and then do the AND:</p>
<pre><code class="language-ignore">  0x8  1000
&amp; 0x3  0011
------ ----
  0x0  0000
</code></pre>
<p>Bitwise AND is often used to get the value at a specific bit or byte number. For example, if you have a 4 byte value and you just want the value in the third byte position you can AND the number with another value that has zeros in every position but the thrid byte - this practice is known as &quot;bit masking&quot;.</p>
<a class="header" href="#or-" id="or-"><h2>OR (|)</h2></a>
<p>Just like bitwise AND, Bitwise OR (|) is similiar to the boolean OR (||) operator except that it operates on each bit of a byte or set of bytes.</p>
<p>If we have two boolean values we already know how to || them:</p>
<pre><code class="language-ignore">true  || true  == true
false || true  == true
true  || false == true
false || false == false
</code></pre>
<p>Let's take a look at a bitwise example:</p>
<pre><code class="language-ignore">  1001
| 1100
------
  1101
</code></pre>
<p>The same advice around hexadecimal applies for bitwise OR as it did for AND. When in doubt, convert to binary and go bit by bit.</p>
<p>Bitwise OR can be used to combine two binary values together. For example, if you want to be sure that a value has it's least significant bit set to 1, you can OR it with 0b1.</p>
<a class="header" href="#shift--" id="shift--"><h2>Shift (&lt;&lt; &gt;&gt;)</h2></a>
<p>Bit shifting is the practice of moving bits in order to different digit positions.</p>
<p>To accomplish this first we look at the operator to see what direction we're going: <code>&lt;&lt;</code> for left and <code>&gt;&gt;</code> for right. We then take each bit and shift it over as many places as the number to the right of the operator tells us to. Any numbers that no longer fit (i.e. they've been shift off the edge of the number) disappear. All digit places that are left empty by the shifting get replaced by 0s.</p>
<p>Let's take a look at some examples:</p>
<pre><code class="language-ignore">1001 &gt;&gt; 1 == 0100
1001 &gt;&gt; 2 == 0010
1001 &gt;&gt; 3 == 0001
1001 &gt;&gt; 4 == 0000

1101 &lt;&lt; 1 == 1010
1101 &lt;&lt; 2 == 0100
1101 &lt;&lt; 3 == 1000
1101 &lt;&lt; 4 == 0000
</code></pre>
<p>Again, if you have a number in hexadecimal notation, you can first convert it to binary and go bit by bit.</p>
<p>One thing bit shifting is used for is to get the values of certain bytes in a number composed of many bytes. For example, in the following snippet, we're trying to get the value of the most significant byte:</p>
<pre><code class="language-ignore">0x1c74a3 &gt;&gt; 16 == 0x1c
</code></pre>
<a class="header" href="#resources" id="resources"><h1>Resources</h1></a>
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>DMG-01: Instruction Guide</title>
    <link rel="stylesheet" href="index.css">
  </head>
  <body>
    <div>
      <header class="header">
        <div class="title">
          Instruction Guide
        </div>
        <table id="instruction-table">
          <tr>
            <th></th>
            <th>0x0</th>
            <th>0x1</th>
            <th>0x2</th>
            <th>0x3</th>
            <th>0x4</th>
            <th>0x5</th>
            <th>0x6</th>
            <th>0x7</th>
            <th>0x8</th>
            <th>0x9</th>
            <th>0xa</th>
            <th>0xb</th>
            <th>0xc</th>
            <th>0xd</th>
            <th>0xe</th>
            <th>0xf</th>
          </tr>
          <tr>
            <th>0x0</th>
            <td class="row1 column1"></td>
            <td class="row1 column2"></td>
            <td class="row1 column3"></td>
            <td class="row1 column4"></td>
            <td class="row1 column5"></td>
            <td class="row1 column6"></td>
            <td class="row1 column7"></td>
            <td class="row1 column8"></td>
            <td class="row1 column9"></td>
            <td class="row1 column10"><a href="#ADD">ADD HL,BC</a></td>
            <td class="row1 column11"></td>
            <td class="row1 column12"></td>
            <td class="row1 column13"></td>
            <td class="row1 column14"></td>
            <td class="row1 column15"></td>
            <td class="row1 column16"></td>
          </tr>
          <tr>
            <th>0x1</th>
            <td class="row2 column1"></td>
            <td class="row2 column2"></td>
            <td class="row2 column3"></td>
            <td class="row2 column4"></td>
            <td class="row2 column5"></td>
            <td class="row2 column6"></td>
            <td class="row2 column7"></td>
            <td class="row2 column8"></td>
            <td class="row2 column9"></td>
            <td class="row2 column10"><a href="#ADD">ADD HL,DE</a></td>
            <td class="row2 column11"></td>
            <td class="row2 column12"></td>
            <td class="row2 column13"></td>
            <td class="row2 column14"></td>
            <td class="row2 column15"></td>
            <td class="row2 column16"></td>
          </tr>
          <tr>
            <th>0x2</th>
            <td class="row3 column1"></td>
            <td class="row3 column2"></td>
            <td class="row3 column3"></td>
            <td class="row3 column4"></td>
            <td class="row3 column5"></td>
            <td class="row3 column6"></td>
            <td class="row3 column7"></td>
            <td class="row3 column8"></td>
            <td class="row3 column9"></td>
            <td class="row3 column10"><a href="#ADD">ADD HL,HL</a></td>
            <td class="row3 column11"></td>
            <td class="row3 column12"></td>
            <td class="row3 column13"></td>
            <td class="row3 column14"></td>
            <td class="row3 column15"></td>
            <td class="row3 column16"></td>
          </tr>
          <tr>
            <th>0x3</th>
            <td class="row4 column1"></td>
            <td class="row4 column2"></td>
            <td class="row4 column3"></td>
            <td class="row4 column4"></td>
            <td class="row4 column5"></td>
            <td class="row4 column6"></td>
            <td class="row4 column7"></td>
            <td class="row4 column8"></td>
            <td class="row4 column9"></td>
            <td class="row4 column10"><a href="#ADD">ADD HL,SP</a></td>
            <td class="row4 column11"></td>
            <td class="row4 column12"></td>
            <td class="row4 column13"></td>
            <td class="row4 column14"></td>
            <td class="row4 column15"></td>
            <td class="row4 column16"></td>
          </tr>
          <tr>
            <th>0x4</th>
            <td class="row5 column1"></td>
            <td class="row5 column2"></td>
            <td class="row5 column3"></td>
            <td class="row5 column4"></td>
            <td class="row5 column5"></td>
            <td class="row5 column6"></td>
            <td class="row5 column7"></td>
            <td class="row5 column8"></td>
            <td class="row5 column9"></td>
            <td class="row5 column10"></td>
            <td class="row5 column11"></td>
            <td class="row5 column12"></td>
            <td class="row5 column13"></td>
            <td class="row5 column14"></td>
            <td class="row5 column15"></td>
            <td class="row5 column16"></td>
          </tr>
          <tr>
            <th>0x5</th>
            <td class="row6 column1"></td>
            <td class="row6 column2"></td>
            <td class="row6 column3"></td>
            <td class="row6 column4"></td>
            <td class="row6 column5"></td>
            <td class="row6 column6"></td>
            <td class="row6 column7"></td>
            <td class="row6 column8"></td>
            <td class="row6 column9"></td>
            <td class="row6 column10"></td>
            <td class="row6 column11"></td>
            <td class="row6 column12"></td>
            <td class="row6 column13"></td>
            <td class="row6 column14"></td>
            <td class="row6 column15"></td>
            <td class="row6 column16"></td>
          </tr>
          <tr>
            <th>0x6</th>
            <td class="row7 column1"></td>
            <td class="row7 column2"></td>
            <td class="row7 column3"></td>
            <td class="row7 column4"></td>
            <td class="row7 column5"></td>
            <td class="row7 column6"></td>
            <td class="row7 column7"></td>
            <td class="row7 column8"></td>
            <td class="row7 column9"></td>
            <td class="row7 column10"></td>
            <td class="row7 column11"></td>
            <td class="row7 column12"></td>
            <td class="row7 column13"></td>
            <td class="row7 column14"></td>
            <td class="row7 column15"></td>
            <td class="row7 column16"></td>
          </tr>
          <tr>
            <th>0x7</th>
            <td class="row8 column1"></td>
            <td class="row8 column2"></td>
            <td class="row8 column3"></td>
            <td class="row8 column4"></td>
            <td class="row8 column5"></td>
            <td class="row8 column6"></td>
            <td class="row8 column7"></td>
            <td class="row8 column8"></td>
            <td class="row8 column9"></td>
            <td class="row8 column10"></td>
            <td class="row8 column11"></td>
            <td class="row8 column12"></td>
            <td class="row8 column13"></td>
            <td class="row8 column14"></td>
            <td class="row8 column15"></td>
            <td class="row8 column16"></td>
          </tr>
          <tr>
            <th>0x8</th>
            <td class="row9 column1"><a href="#ADD">ADD A,B</a></td>
            <td class="row9 column2"><a href="#ADD">ADD A,C</a></td>
            <td class="row9 column3"><a href="#ADD">ADD A,D</a></td>
            <td class="row9 column4"><a href="#ADD">ADD A,E</a></td>
            <td class="row9 column5"><a href="#ADD">ADD A,H</a></td>
            <td class="row9 column6"><a href="#ADD">ADD A,L</a></td>
            <td class="row9 column7"><a href="#ADD">ADD A,(HL)</a></td>
            <td class="row9 column8"><a href="#ADD">ADD A,A</a></td>
            <td class="row9 column9"></td>
            <td class="row9 column10"></td>
            <td class="row9 column11"></td>
            <td class="row9 column12"></td>
            <td class="row9 column13"></td>
            <td class="row9 column14"></td>
            <td class="row9 column15"></td>
            <td class="row9 column16"></td>
          </tr>
          <tr>
            <th>0x9</th>
            <td class="row10 column1"></td>
            <td class="row10 column2"></td>
            <td class="row10 column3"></td>
            <td class="row10 column4"></td>
            <td class="row10 column5"></td>
            <td class="row10 column6"></td>
            <td class="row10 column7"></td>
            <td class="row10 column8"></td>
            <td class="row10 column9"></td>
            <td class="row10 column10"></td>
            <td class="row10 column11"></td>
            <td class="row10 column12"></td>
            <td class="row10 column13"></td>
            <td class="row10 column14"></td>
            <td class="row10 column15"></td>
            <td class="row10 column16"></td>
          </tr>
          <tr>
            <th>0xa</th>
            <td class="row11 column1"></td>
            <td class="row11 column2"></td>
            <td class="row11 column3"></td>
            <td class="row11 column4"></td>
            <td class="row11 column5"></td>
            <td class="row11 column6"></td>
            <td class="row11 column7"></td>
            <td class="row11 column8"></td>
            <td class="row11 column9"></td>
            <td class="row11 column10"></td>
            <td class="row11 column11"></td>
            <td class="row11 column12"></td>
            <td class="row11 column13"></td>
            <td class="row11 column14"></td>
            <td class="row11 column15"></td>
            <td class="row11 column16"></td>
          </tr>
          <tr>
            <th>0xb</th>
            <td class="row12 column1"></td>
            <td class="row12 column2"></td>
            <td class="row12 column3"></td>
            <td class="row12 column4"></td>
            <td class="row12 column5"></td>
            <td class="row12 column6"></td>
            <td class="row12 column7"></td>
            <td class="row12 column8"></td>
            <td class="row12 column9"></td>
            <td class="row12 column10"></td>
            <td class="row12 column11"></td>
            <td class="row12 column12"></td>
            <td class="row12 column13"></td>
            <td class="row12 column14"></td>
            <td class="row12 column15"></td>
            <td class="row12 column16"></td>
          </tr>
          <tr>
            <th>0xc</th>
            <td class="row13 column1"></td>
            <td class="row13 column2"></td>
            <td class="row13 column3"></td>
            <td class="row13 column4"></td>
            <td class="row13 column5"></td>
            <td class="row13 column6"></td>
            <td class="row13 column7"><a href="#ADD">ADD A,d8</a></td>
            <td class="row13 column8"></td>
            <td class="row13 column9"></td>
            <td class="row13 column10"></td>
            <td class="row13 column11"></td>
            <td class="row13 column12"></td>
            <td class="row13 column13"></td>
            <td class="row13 column14"></td>
            <td class="row13 column15"></td>
            <td class="row13 column16"></td>
          </tr>
          <tr>
            <th>0xd</th>
            <td class="row14 column1"></td>
            <td class="row14 column2"></td>
            <td class="row14 column3"></td>
            <td class="row14 column4"></td>
            <td class="row14 column5"></td>
            <td class="row14 column6"></td>
            <td class="row14 column7"></td>
            <td class="row14 column8"></td>
            <td class="row14 column9"></td>
            <td class="row14 column10"></td>
            <td class="row14 column11"></td>
            <td class="row14 column12"></td>
            <td class="row14 column13"></td>
            <td class="row14 column14"></td>
            <td class="row14 column15"></td>
            <td class="row14 column16"></td>
          </tr>
          <tr>
            <th>0xe</th>
            <td class="row15 column1"></td>
            <td class="row15 column2"></td>
            <td class="row15 column3"></td>
            <td class="row15 column4"></td>
            <td class="row15 column5"></td>
            <td class="row15 column6"></td>
            <td class="row15 column7"></td>
            <td class="row15 column8"></td>
            <td class="row15 column9"></td>
            <td class="row15 column10"></td>
            <td class="row15 column11"></td>
            <td class="row15 column12"></td>
            <td class="row15 column13"></td>
            <td class="row15 column14"></td>
            <td class="row15 column15"></td>
            <td class="row15 column16"></td>
          </tr>
          <tr>
            <th>0xf</th>
            <td class="row16 column1"></td>
            <td class="row16 column2"></td>
            <td class="row16 column3"></td>
            <td class="row16 column4"></td>
            <td class="row16 column5"></td>
            <td class="row16 column6"></td>
            <td class="row16 column7"></td>
            <td class="row16 column8"></td>
            <td class="row16 column9"></td>
            <td class="row16 column10"></td>
            <td class="row16 column11"></td>
            <td class="row16 column12"></td>
            <td class="row16 column13"></td>
            <td class="row16 column14"></td>
            <td class="row16 column15"></td>
            <td class="row16 column16"></td>
          </tr>
        </table>
      </header>
      <div id="instructions-list">
        <div class="heading">Arithmetic Instructions</div>
        <div id="ADD" class="instruction-name">
          <div>ADD</div>
          <div class="line"></div>
          <div class="instruction-entry">
            <div class="instruction-info">
              <div class="quick-view">
                <div class="row">
                  <div>1</div>
                  <div>4</div>
                </div>
                <div class="row">
                  <div>?</div>
                  <div>0</div>
                  <div>?</div>
                  <div>?</div>
                </div>
              </div>
              <div class="description">Add the value stored in a target register to the value in register A</div>
              <div>Targets: A, B, C, D, E, H, L, BC, DE, HL, SP, d8, SP</div>
            </div>
          </div>
          <div class="playground"></div>
        </div>
      </div>
  </body>
  <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha256-3edrmyuQ0w65f8gfBsqowzjJe2iM6n0nKciPUp8y+7E=" crossorigin="anonymous"></script>
  <script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
  <script src="cpu.js"></script>
  <script src="index.js"></script>
</html>
<a class="header" href="#cartridge-header" id="cartridge-header"><h1>Cartridge Header</h1></a>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
